<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>單棲情緒</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunmaer.github.io/"/>
  <updated>2017-09-18T12:15:00.000Z</updated>
  <id>http://sunmaer.github.io/</id>
  
  <author>
    <name>sunmaer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tab页通信</title>
    <link href="http://sunmaer.github.io/2017/09/18/Tab%E9%A1%B5%E9%80%9A%E4%BF%A1/"/>
    <id>http://sunmaer.github.io/2017/09/18/Tab页通信/</id>
    <published>2017-09-18T12:15:00.000Z</published>
    <updated>2017-09-18T12:15:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>金山WPS前端笔试题</title>
    <link href="http://sunmaer.github.io/2017/09/16/%E9%87%91%E5%B1%B1WPS%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://sunmaer.github.io/2017/09/16/金山WPS前端笔试题/</id>
    <published>2017-09-16T03:22:11.000Z</published>
    <updated>2017-09-18T12:16:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="金山办公软件web前端开发工程师笔试题"><a href="#金山办公软件web前端开发工程师笔试题" class="headerlink" title="金山办公软件web前端开发工程师笔试题"></a>金山办公软件web前端开发工程师笔试题</h2><a id="more"></a>
<h3 id="1、列出http协议头部信息并简单描述其作用。"><a href="#1、列出http协议头部信息并简单描述其作用。" class="headerlink" title="1、列出http协议头部信息并简单描述其作用。"></a>1、列出http协议头部信息并简单描述其作用。</h3><ul>
<li>通用首部</li>
</ul>
<blockquote>
<p>客户端和服务端都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。  </p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">允许客户端和服务器指定与请求/响应连接有关的选项</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">提供日期和时间标志，说明报文是什么时间创建的</td>
</tr>
<tr>
<td style="text-align:center">MIME-Version</td>
<td style="text-align:center">给出了发送端使用的MIME版本</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">如果报文采用了分块传输编码方式，就可以用这个首部列出位于报文拖挂部分的首部集合</td>
</tr>
<tr>
<td style="text-align:center">Update</td>
<td style="text-align:center">给出了发送端可能想要“升级”使用的新版本或协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">显示了报文经过的中间节点（代理、网关）</td>
</tr>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">用于随报文传送缓存指示</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">另一种随报文传送指示的方式，但并不专用于缓存</td>
</tr>
</tbody>
</table>
<ul>
<li>请求首部</li>
</ul>
<blockquote>
<p>请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。</p>
</blockquote>
<p>1、请求的信息性首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Client-IP</td>
<td style="text-align:center">提供了运行客户端的机器的IP地址</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">提供了客户端用户的Email地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">给出了接受请求的服务器的主机名和端口号</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">提供了包含当前请求URI的文档的URL</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">将发起请求的应用程序名称告知服务器</td>
</tr>
</tbody>
</table>
<p>2、Accept首部 客户端将其喜好和能力告知服务器</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">告知服务器能够发送哪些媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">告知服务器能够发送哪些字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">告知服务器能够发送哪些编码方式</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">告知服务器能够发送哪些语言</td>
</tr>
</tbody>
</table>
<p>3、条件请求首部 客户端为请求加上某些限制</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">允许客户端列出某请求所要求的服务器行为</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">如果实体标记与文档当前的实体标记相匹配，就获取这份文档</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">除非在某个指定的日期之后资源被修改过，否则就限制这个请求</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">除非在某个指定的日期之后资源没有被修改过，否则就限制这个请求</td>
</tr>
</tbody>
</table>
<p>4、安全请求首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Authorization</td>
<td style="text-align:center">包含了客户端提供给服务器，以便对其自身进行认证的数据</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">客户端用它向服务器发送一个令牌-它并不是真正的安全首部，但确实隐含了安全功能</td>
</tr>
<tr>
<td style="text-align:center">Cookie2</td>
<td style="text-align:center">用来说明请求端支持的cookie版本</td>
</tr>
</tbody>
</table>
<p>5、代理请求首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Max-Forward</td>
<td style="text-align:center">在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数-与TRACE方法一起使用</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">与Authorization首部相同，但这个首部是在与代理进行认证时使用的</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Connection</td>
<td style="text-align:center">与Connection首部相同，但这个首部是在与代理建立连接时使用的</td>
</tr>
</tbody>
</table>
<ul>
<li>响应首部</li>
</ul>
<blockquote>
<p>响应首部为客户端提供了一些额外信息</p>
</blockquote>
<p>1、响应的信息性首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">响应持续时间</td>
</tr>
<tr>
<td style="text-align:center">Public</td>
<td style="text-align:center">服务器为其资源支持的请求方法列表</td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">如果资源不可用的话，在此日期或时间重试</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">服务器应用程序软件的名称和版本</td>
</tr>
</tbody>
</table>
<p>2、协商首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Range</td>
<td style="text-align:center">对此资源来说，服务器可接受的范围类型</td>
</tr>
</tbody>
</table>
<p>3、安全响应首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Set-Cookie</td>
<td style="text-align:center">不是真正的安全首部，但隐含有安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识</td>
</tr>
<tr>
<td style="text-align:center">Set-Cookie2</td>
<td style="text-align:center">与Set-Cookie类似</td>
</tr>
</tbody>
</table>
<ul>
<li>实体首部</li>
</ul>
<blockquote>
<p>实体首部用来描述HTTP报文的负荷。请求和响应报文中都可能出现这些首部。</p>
</blockquote>
<p>1、实体的信息性首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">列出了可以对此实体执行的请求方法</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">告知客户端实体实际上位于何处，用于将接收端定向到资源的位置上去</td>
</tr>
</tbody>
</table>
<p>2、内容首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">主体的长度或尺寸</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">资源实际所处的位置</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">主体的对象类型</td>
</tr>
</tbody>
</table>
<p>3、实体缓存首部</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">与此实体相关的实体标记</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">实体不再有效，要从原始的源端再次获取此实体的日期和时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">这个实体最后一次被修改的日期和时间</td>
</tr>
</tbody>
</table>
<h3 id="2、浏览器如何请求并渲染页面的。"><a href="#2、浏览器如何请求并渲染页面的。" class="headerlink" title="2、浏览器如何请求并渲染页面的。"></a>2、浏览器如何请求并渲染页面的。</h3><ul>
<li><p>首先，在浏览器地址栏中输入url。</p>
</li>
<li><p>浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则继续以下操作。</p>
</li>
<li><p>在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。</p>
</li>
<li><p>浏览器向服务器发起tcp连接，tcp三次握手连接。</p>
</li>
<li><p>握手成功后，浏览器向服务器发送http请求，请求数据包。</p>
</li>
<li><p>服务器处理收到的请求，将数据返回至浏览器。</p>
</li>
<li><p>浏览器收到HTTP响应。</p>
</li>
<li><p>读取页面内容，浏览器渲染，解析html源码。</p>
</li>
<li><p>生成Dom树、解析css样式、js交互。</p>
</li>
<li><p>四次挥手断开连接。</p>
</li>
</ul>
<h3 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、<figure class="highlight plain"><figcaption><span>id="div1"><div id="div2"></div>```在不确定div2大小的情况下实现div2上下左右居中。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 伪元素占位方案</div><div class="line"></div><div class="line">```bash</div><div class="line">#div1 &#123;</div><div class="line">	text-align: center; /* 水平居中 */</div><div class="line">	font-size: 0; /* 消除空隙 */</div><div class="line">&#125;</div><div class="line">#div1::before &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">#div1::before, #div2 &#123;</div><div class="line">	display: inline-block;</div><div class="line">	vertical-align: middle; /* 调整line-box的基线位置 */</div><div class="line">	font-size: 14px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></h3><ul>
<li>利用 transform 属性</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#div2 &#123;</span></div><div class="line">	position: absolute;</div><div class="line">	top: 50%;</div><div class="line">	left: 50%;</div><div class="line">	transform: translate(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>table-cell 方案</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#div1 &#123;</span></div><div class="line">	display: table-cell;</div><div class="line">	text-align: center;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line"><span class="comment">#div2 &#123;</span></div><div class="line">	display: inline-block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>flex 布局</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#div1 &#123;</span></div><div class="line">	display: flex;</div><div class="line">	justify-content: center;</div><div class="line">	align-items: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>flex+margin 方案</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#div1 &#123;</span></div><div class="line">	display: flex;</div><div class="line">	margin: 0;</div><div class="line">&#125;</div><div class="line"><span class="comment">#div2 &#123;</span></div><div class="line">	margin: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、js实现一个单例模式。"><a href="#4、js实现一个单例模式。" class="headerlink" title="4、js实现一个单例模式。"></a>4、js实现一个单例模式。</h3><h3 id="5、js实现将location-search转换成map的方法。"><a href="#5、js实现将location-search转换成map的方法。" class="headerlink" title="5、js实现将location.search转换成map的方法。"></a>5、js实现将location.search转换成map的方法。</h3><h3 id="6、100万个不相等的乱序的整数，用最快的方法将其分成相等的两部分，要求前一部分每个数都比后一部分每个数小？"><a href="#6、100万个不相等的乱序的整数，用最快的方法将其分成相等的两部分，要求前一部分每个数都比后一部分每个数小？" class="headerlink" title="6、100万个不相等的乱序的整数，用最快的方法将其分成相等的两部分，要求前一部分每个数都比后一部分每个数小？"></a>6、100万个不相等的乱序的整数，用最快的方法将其分成相等的两部分，要求前一部分每个数都比后一部分每个数小？</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;金山办公软件web前端开发工程师笔试题&quot;&gt;&lt;a href=&quot;#金山办公软件web前端开发工程师笔试题&quot; class=&quot;headerlink&quot; title=&quot;金山办公软件web前端开发工程师笔试题&quot;&gt;&lt;/a&gt;金山办公软件web前端开发工程师笔试题&lt;/h2&gt;
    
    </summary>
    
      <category term="笔试题" scheme="http://sunmaer.github.io/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="笔试题" scheme="http://sunmaer.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0中数据可视化库实现关系图</title>
    <link href="http://sunmaer.github.io/2017/08/18/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E5%9B%BE/"/>
    <id>http://sunmaer.github.io/2017/08/18/Vue中使用数据可视化库实现关系图/</id>
    <published>2017-08-18T14:49:15.000Z</published>
    <updated>2017-08-18T14:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目地址：<a href="https://github.com/sunmaer/vue-charts" target="_blank" rel="external">https://github.com/sunmaer/vue-charts</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a><a href="http://echarts.baidu.com/index.html" target="_blank" rel="external">Echarts</a></h2><blockquote>
<p>版本：3.6.2</p>
</blockquote>
<ul>
<li>树状图<br>Echarts3中删除了tree图，但是我们通过自定义节点坐标还是可以实现一个简单的树图。给定节点层级，然后通过层级平均分布节点，不过这种方法存在的问题还是不少，建议使用D3.js实现树图，见后面。</li>
</ul>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/tree.png" alt="树状图"></p>
<ul>
<li>人物关系图</li>
</ul>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/net.png" alt="人物关系图"></p>
<h2 id="D3-js-组织结构图示例"><a href="#D3-js-组织结构图示例" class="headerlink" title="D3.js 组织结构图示例"></a><a href="https://d3js.org/" target="_blank" rel="external">D3.js</a> 组织结构图示例</h2><blockquote>
<p>版本：4.10.0</p>
</blockquote>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/organise.png" alt="组织结构图"></p>
<h2 id="jsPlumb-流程图示例"><a href="#jsPlumb-流程图示例" class="headerlink" title="jsPlumb 流程图示例"></a><a href="https://www.jsplumbtoolkit.com/community/doc/home.html" target="_blank" rel="external">jsPlumb</a> 流程图示例</h2><blockquote>
<p>版本：2.4.3</p>
</blockquote>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/flow.png" alt="流程图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/sunmaer/vue-charts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/sunmaer/vue-charts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="vue" scheme="http://sunmaer.github.io/categories/vue/"/>
    
    
      <category term="数据可视化" scheme="http://sunmaer.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="Echarts" scheme="http://sunmaer.github.io/tags/Echarts/"/>
    
      <category term="jsPlumb" scheme="http://sunmaer.github.io/tags/jsPlumb/"/>
    
      <category term="D3.js" scheme="http://sunmaer.github.io/tags/D3-js/"/>
    
      <category term="组织结构图" scheme="http://sunmaer.github.io/tags/%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/"/>
    
      <category term="树状图" scheme="http://sunmaer.github.io/tags/%E6%A0%91%E7%8A%B6%E5%9B%BE/"/>
    
      <category term="关系图" scheme="http://sunmaer.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>策略模式实现表单验证</title>
    <link href="http://sunmaer.github.io/2017/08/10/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    <id>http://sunmaer.github.io/2017/08/10/策略模式实现表单验证/</id>
    <published>2017-08-10T01:57:33.000Z</published>
    <updated>2017-09-02T11:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统表单验证方式存在的问题："><a href="#传统表单验证方式存在的问题：" class="headerlink" title="传统表单验证方式存在的问题："></a>传统表单验证方式存在的问题：</h2><ul>
<li>验证函数里包含很多的 if-else 语句</li>
<li>验证函数缺乏弹性，如果增加一种新的校验规则，必须深入验证函数的内部实现，违反了开放-封闭原则</li>
<li>算法的复用性差，如果程序中增加了另一个表单，这个表单也需要进行一些类似的校验，那我们只能复制粘贴</li>
</ul>
<a id="more"></a>
<h2 id="策略模式重构表单验证"><a href="#策略模式重构表单验证" class="headerlink" title="策略模式重构表单验证"></a>策略模式重构表单验证</h2><blockquote>
<p>策略模式是指一系列的算法定义，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。策略模式优点：策略模式提供了管理相关的算法族的办法、策略模式提供了可以替换继承关系的办法、使用策略模式可以避免使用多重条件转移语句。</p>
</blockquote>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>Context 环境角色：持有一个策略类的引用，最终给客户端调用</p>
<ul>
<li>需要使用 ConcreteStrategy 提供的算法</li>
<li>内部维护一个 Strategy 的实例</li>
<li>负责动态设置运行时 Strategy 具体的实现算法</li>
<li>负责跟 Strategy 之间的交互和数据传递</li>
</ul>
<p>Strategy 抽象策略角色：策略类，通常由一个接口或者抽象类实现</p>
<ul>
<li>定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，Context使用这个接口调用不同的算法，一般使用接口或抽象类实现</li>
</ul>
<p>ConcreteStrategy 具体策略角色：包装了相关的算法和行为</p>
<ul>
<li>实现 Strategy 定义的接口，提供具体的算法实现</li>
</ul>
<h3 id="具体策略角色"><a href="#具体策略角色" class="headerlink" title="具体策略角色"></a>具体策略角色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/* 策略对象 */</div><div class="line">const strategies = &#123;</div><div class="line">	isNonEmpty(value, errorMsg) &#123;</div><div class="line">		<span class="built_in">return</span> value === <span class="string">''</span> ? </div><div class="line">			errorMsg : void 0</div><div class="line">	&#125;,</div><div class="line">	minLength(value, length, errorMsg) &#123;</div><div class="line">		<span class="built_in">return</span> value.length &lt; length ? </div><div class="line">			errorMsg : void 0</div><div class="line">	&#125;,</div><div class="line">	isMoblie(value, errorMsg) &#123;</div><div class="line">		<span class="built_in">return</span> !/^1(3|5|7|8|9)[0-9]&#123;9&#125;$/.<span class="built_in">test</span>(value) ? </div><div class="line">			errorMsg : void 0</div><div class="line">	&#125;,</div><div class="line">	isEmail(value, errorMsg) &#123;</div><div class="line">		<span class="built_in">return</span> !/^\w+([+-.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/.<span class="built_in">test</span>(value) ?</div><div class="line">	errorMsg : void 0</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="抽象策略角色"><a href="#抽象策略角色" class="headerlink" title="抽象策略角色"></a>抽象策略角色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/* 抽象策略对象 */</div><div class="line">class Validator &#123;</div><div class="line">	<span class="function"><span class="title">constructor</span></span>() &#123;</div><div class="line">		this.cache = [] // 保存校验规则</div><div class="line">	&#125;</div><div class="line">	add(dom, rules) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">let</span> rule of rules) &#123;</div><div class="line">			<span class="built_in">let</span> strategyAry = rule.strategy.split(<span class="string">':'</span>)</div><div class="line">			<span class="built_in">let</span> errorMsg = rule.errorMsg</div><div class="line">			this.cache.push(() =&gt; &#123;</div><div class="line">				<span class="built_in">let</span> strategy = strategyAry.shift()</div><div class="line">				strategyAry.unshift(dom.value)</div><div class="line">				strategyAry.push(errorMsg)</div><div class="line">				<span class="built_in">return</span> strategies[strategy].apply(dom, strategyAry)</div><div class="line">			&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">let</span> ValidatorFunc of this.cache) &#123;</div><div class="line">			<span class="built_in">let</span> errorMsg = ValidatorFunc()</div><div class="line">			<span class="keyword">if</span>(errorMsg) &#123;</div><div class="line">				<span class="built_in">return</span> errorMsg</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="环境角色"><a href="#环境角色" class="headerlink" title="环境角色"></a>环境角色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/* 客户端调用代码 */</div><div class="line"><span class="built_in">let</span> form = document.getElementById(<span class="string">"form"</span>)</div><div class="line">const validatorFunc = () =&gt; &#123;</div><div class="line">	<span class="built_in">let</span> validator = new Validator()</div><div class="line">	validator.add(form.name, [</div><div class="line">		&#123;</div><div class="line">			strategy: <span class="string">'isNonEmpty'</span>,</div><div class="line">			errorMsg: <span class="string">'用户名不能为空'</span></div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			strategy: <span class="string">'minLength:6'</span>,</div><div class="line">			errorMsg: <span class="string">'用户名长度不能小于6位'</span></div><div class="line">		&#125;</div><div class="line">	])</div><div class="line"></div><div class="line">	validator.add(form.email, [</div><div class="line">		&#123;</div><div class="line">			strategy: <span class="string">'isNonEmpty'</span>,</div><div class="line">			errorMsg: <span class="string">'邮箱不能为空'</span></div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			strategy: <span class="string">'isEmail'</span>,</div><div class="line">			errorMsg: <span class="string">'邮箱格式不正确'</span></div><div class="line">		&#125;</div><div class="line">	])</div><div class="line"></div><div class="line">	validator.add(form.tel, [</div><div class="line">		&#123;</div><div class="line">			strategy: <span class="string">'isNonEmpty'</span>,</div><div class="line">			errorMsg: <span class="string">'手机号码不能为空'</span></div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			strategy: <span class="string">'isMoblie'</span>,</div><div class="line">			errorMsg: <span class="string">'手机号码格式不正确'</span></div><div class="line">		&#125;</div><div class="line">	])</div><div class="line">	<span class="built_in">let</span> errorMsg = validator.start()</div><div class="line">	<span class="built_in">return</span> errorMsg</div><div class="line">&#125;</div><div class="line"></div><div class="line">form.addEventListener(<span class="string">'submit'</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">	<span class="built_in">let</span> errorMsg = validatorFunc()</div><div class="line">	<span class="keyword">if</span>(errorMsg) &#123;</div><div class="line">		alert(errorMsg)</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>参考博客：<a href="https://github.com/jawil/blog/issues/19" target="_blank" rel="external">https://github.com/jawil/blog/issues/19</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;传统表单验证方式存在的问题：&quot;&gt;&lt;a href=&quot;#传统表单验证方式存在的问题：&quot; class=&quot;headerlink&quot; title=&quot;传统表单验证方式存在的问题：&quot;&gt;&lt;/a&gt;传统表单验证方式存在的问题：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;验证函数里包含很多的 if-else 语句&lt;/li&gt;
&lt;li&gt;验证函数缺乏弹性，如果增加一种新的校验规则，必须深入验证函数的内部实现，违反了开放-封闭原则&lt;/li&gt;
&lt;li&gt;算法的复用性差，如果程序中增加了另一个表单，这个表单也需要进行一些类似的校验，那我们只能复制粘贴&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://sunmaer.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="策略模式" scheme="http://sunmaer.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript插入元素</title>
    <link href="http://sunmaer.github.io/2017/07/29/JavaScript%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0/"/>
    <id>http://sunmaer.github.io/2017/07/29/JavaScript插入元素/</id>
    <published>2017-07-29T03:21:51.000Z</published>
    <updated>2017-08-29T03:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我们平时经常会遇到动态插入 DOM 元素的场合，而在 JavaScript 中有多种方式可以实现插入 DOM，总结如下：</p>
</blockquote>
<a id="more"></a>
<h2 id="insertBefore-在指定的已有的子节点之前插入新节点"><a href="#insertBefore-在指定的已有的子节点之前插入新节点" class="headerlink" title="insertBefore()    在指定的已有的子节点之前插入新节点"></a>insertBefore()    在指定的已有的子节点之前插入新节点</h2><ul>
<li>调用了10000次ul.insertBefore()，每次都要产生一次页面渲染</li>
<li>在父元素末尾插入新节点性能和appendChild()差不多，如果在指定子节点前插入新节点，影响文档树中的其他元素，渲染开销较大</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">	<span class="built_in">let</span> li = document.createElement(<span class="string">'li'</span>)</div><div class="line">	<span class="built_in">let</span> a = document.createElement(<span class="string">'a'</span>)</div><div class="line">	<span class="built_in">let</span> text = document.createTextNode(<span class="string">'insertBefore()-'</span> + i)</div><div class="line">	a.appendChild(text)</div><div class="line">	li.appendChild(a)</div><div class="line">	ul.insertBefore(li, null)  // 第二个参数为 null 则在末尾插入新节点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="appendChild-向元素添加新的子节点，作为最后一个子节点"><a href="#appendChild-向元素添加新的子节点，作为最后一个子节点" class="headerlink" title="appendChild()    向元素添加新的子节点，作为最后一个子节点"></a>appendChild()    向元素添加新的子节点，作为最后一个子节点</h2><ul>
<li>调用了10000次ul.appendChild()，每次都要产生一次页面渲染</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">  <span class="built_in">let</span> li = document.createElement(<span class="string">'li'</span>)</div><div class="line">  <span class="built_in">let</span> a = document.createElement(<span class="string">'a'</span>)</div><div class="line">  <span class="built_in">let</span> text = document.createTextNode(<span class="string">'appendChild()-'</span> + i)</div><div class="line">  a.appendChild(text)</div><div class="line">  li.appendChild(a)</div><div class="line">  ul.appendChild(li)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="innerHTML-设置或返回元素的内容"><a href="#innerHTML-设置或返回元素的内容" class="headerlink" title="innerHTML 设置或返回元素的内容"></a>innerHTML 设置或返回元素的内容</h2><ul>
<li>只需要一次页面渲染</li>
<li>innerHTML 插入上万个节点的时候，如果要插入的DIV里是空的，那么用innerHTML 插入是最好的选择，速度也是最快的，但是当第二次插入的时候，你就会发现速度降低。如果div里已经有数据，innerHTML会逐一删除，然后再插入的新的数据，速度大大降低，此时建议使用文档片段方式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> liString = <span class="string">''</span></div><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">  liString += <span class="string">'&lt;li&gt;&lt;a href=""&gt;innerHTML-'</span> + i +<span class="string">'&lt;/a&gt;&lt;/li&gt;'</span></div><div class="line">&#125;</div><div class="line">ul.innerHTML = liString</div></pre></td></tr></table></figure>
<h2 id="文档片段-推荐）"><a href="#文档片段-推荐）" class="headerlink" title="文档片段(推荐）"></a>文档片段(推荐）</h2><ul>
<li>只需要一次页面渲染</li>
<li>虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。可以通过 appendChild() 或者 insertBefore() 将文档片段中内容添加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有子节点添加到相应位置上；文档片段本身永远不会成为文档树的一部分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var fragment = document.createDocumentFragment()</div><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">  <span class="built_in">let</span> li = document.createElement(<span class="string">'li'</span>)</div><div class="line">  <span class="built_in">let</span> a = document.createElement(<span class="string">'a'</span>)</div><div class="line">  <span class="built_in">let</span> text = document.createTextNode(<span class="string">'DocumentFragment-'</span> + i)</div><div class="line">  a.appendChild(text)</div><div class="line">  li.appendChild(a)</div><div class="line">  fragment.appendChild(li)</div><div class="line">&#125;</div><div class="line">ul.appendChild(fragment)</div></pre></td></tr></table></figure>
<h2 id="Jquery-插入-DOM-元素-append-方法源码"><a href="#Jquery-插入-DOM-元素-append-方法源码" class="headerlink" title="Jquery 插入 DOM 元素 append() 方法源码"></a>Jquery 插入 DOM 元素 append() 方法源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">append: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> domManip( this, arguments, <span class="keyword">function</span>( elem ) &#123;</div><div class="line">    <span class="keyword">if</span> ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) &#123;</div><div class="line">      var target = manipulationTarget( this, elem );</div><div class="line">      target.appendChild( elem );</div><div class="line">    &#125;</div><div class="line">  &#125; );</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们平时经常会遇到动态插入 DOM 元素的场合，而在 JavaScript 中有多种方式可以实现插入 DOM，总结如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="DOM" scheme="http://sunmaer.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件</title>
    <link href="http://sunmaer.github.io/2017/07/19/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    <id>http://sunmaer.github.io/2017/07/19/JavaScript事件/</id>
    <published>2017-07-19T11:27:05.000Z</published>
    <updated>2017-08-30T03:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>浏览器所支持的事件有很多，事件有三个来源：</p>
<p>3级 DOM 事件规范，经过长期的停滞之后，在 W3C 的主持下开始焕发生机。</p>
<p>HTML5 规范以及相关衍生规范的大量新 API 定义了新事件。</p>
<p>基于触摸和支持 JavaScript 的移动设备的出现，比如 iphone，它们需要定义新的触摸和手势事件类型。</p>
</blockquote>
<a id="more"></a> 
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE 的事件流叫做事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>不太具体的节点更早接收到事件，而最具体的节点最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。</p>
<h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><blockquote>
<p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定。这个特性的值应该是能够执行的 JavaScript 代码。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"点击"</span> onclick=<span class="string">"alert('Hello!')"</span> /&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"点击"</span> onclick=<span class="string">"hello()"</span> /&gt;</div></pre></td></tr></table></figure>
<p>通过 event 变量可以直接访问事件对象。在这个函数内部，this 的值等于事件的目标元素。</p>
<p>缺点：</p>
<ul>
<li>时差问题。如果 hello() 函数定义在页面的最底部，如果用户在页面解析 hello() 函数之前单击了按钮，就会引发错误。</li>
<li>HTMl 与 JavaScript 代码紧密耦合。</li>
</ul>
<h3 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h3><blockquote>
<p>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。</p>
</blockquote>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="title">function</span></span>() &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>如果这些代码在页面中位于按钮后面，就有可能在一段时间内怎么单击都没有反应。</p>
<p>程序中的 this 引用当前元素。</p>
<p>将事件处理程序属性的值设为 null 就可以删除事件处理程序。</p>
<h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">	alert(<span class="string">'1'</span>);</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>DOM2级方法添加事件处理程序可以添加多个事件处理程序。</p>
<p>通过 addEventListener() 添加的匿名函数将无法移除。</p>
<p>事件处理程序按照添加它们的顺序触发。</p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段。</p>
<h3 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">	alert(<span class="string">'1'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在使用 attachEvent() 方法情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window。</p>
<p>事件处理程序不是以它们添加的顺序执行，而是相反的顺序被触发。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。</p>
<h3 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h3><p>event对象属性：</p>
<ul>
<li>currentTarget 事件处理程序当前正在处理事件的那个元素</li>
<li>target 事件的实际目标</li>
</ul>
<h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><p>event对象属性：</p>
<ul>
<li>cancelBubble 取消事件冒泡</li>
<li>returnValue 取消事件默认行为</li>
<li>srcElement 事件的目标（与target属性相同）</li>
</ul>
<h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪事件。DOM 访问次数越多，引起浏览器的重绘次数越多。</p>
<blockquote>
<p>事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;浏览器所支持的事件有很多，事件有三个来源：&lt;/p&gt;
&lt;p&gt;3级 DOM 事件规范，经过长期的停滞之后，在 W3C 的主持下开始焕发生机。&lt;/p&gt;
&lt;p&gt;HTML5 规范以及相关衍生规范的大量新 API 定义了新事件。&lt;/p&gt;
&lt;p&gt;基于触摸和支持 JavaScript 的移动设备的出现，比如 iphone，它们需要定义新的触摸和手势事件类型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="事件" scheme="http://sunmaer.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象</title>
    <link href="http://sunmaer.github.io/2017/05/20/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sunmaer.github.io/2017/05/20/JavaScript对象/</id>
    <published>2017-05-20T06:42:06.000Z</published>
    <updated>2017-08-22T14:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>对象是JavaScript的基本数据类型。对象是一种复合值；它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。对象也可以看作是属性的无序集合，每个属性都是一个名值对。</p>
</blockquote>
<a id="more"></a>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 对象直接量</div><div class="line">var person = &#123;</div><div class="line">  name: <span class="string">'sunmaer'</span>,</div><div class="line">  age: 21 // ECMAScript5中，最后一个属性后的逗号将忽略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="通过-new-创建对象"><a href="#通过-new-创建对象" class="headerlink" title="通过 new 创建对象"></a>通过 new 创建对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person2 = new Object();</div><div class="line">person2.name = <span class="string">'sunmaer'</span>;</div><div class="line">person2.age = 21;</div></pre></td></tr></table></figure>
<blockquote>
<p>原型：所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。</p>
</blockquote>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><blockquote>
<p>第一个参数指定对象的原型，第二个参数用以对对象的属性进行进一步描述</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person3 = Object.create(&#123;</div><div class="line">  name: <span class="string">'sunmaer'</span>,</div><div class="line">  age: 21</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>传入参数 null 将创建一个没有原型的新对象</li>
<li>传入 Object.prototype 创建一个普通的空对象（类似通过 {} 或 new Object() 创建的对象)</li>
</ul>
<h1 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h1><h2 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h2><ul>
<li>o 中的属性 p 是只读的：不能给只读属性重新弄赋值</li>
<li>o 中的属性 p 是继承属性，且它是只读的： 不能通过同名自有属性覆盖只读的继承属性</li>
<li>o 中不存在自有属性 p: o 没有使用 setter 方法机场属性 p，并且 o 的可扩展性是 false。</li>
</ul>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><ul>
<li>delete 只是断开属性和宿主对象的联系，而不会去操作属性中的属性</li>
<li>delete 只能删除自有属性，不能删除继承属性</li>
<li>严格模式中，delete 必须显示指定对象及其属性</li>
</ul>
<h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>如果对象的自有属性或继承属性中包含这个属性则返回 true</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(<span class="string">'x'</span> <span class="keyword">in</span> o) // <span class="literal">true</span></div><div class="line">console.log(<span class="string">'y'</span> <span class="keyword">in</span> o) // <span class="literal">false</span></div><div class="line">console.log(<span class="string">'toString'</span> <span class="keyword">in</span> o) // <span class="literal">true</span> o 继承toString属性</div></pre></td></tr></table></figure>
<h3 id="hasOwnProperty-和propertyIsEnumerable"><a href="#hasOwnProperty-和propertyIsEnumerable" class="headerlink" title="hasOwnProperty()和propertyIsEnumerable()"></a>hasOwnProperty()和propertyIsEnumerable()</h3><p>对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性，对于继承属性返回false</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(o.hasOwnProperty(<span class="string">'x'</span>)) // <span class="literal">true</span></div><div class="line">console.log(o.hasOwnProperty(<span class="string">'y'</span>)) // <span class="literal">false</span></div><div class="line">console.log(o.hasOwnProperty(<span class="string">'toString'</span>)) // <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>propertyIsEnumerable() 只有检测到时自身属性且这个属性的可枚举性为 true 时才返回true</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(o.propertyIsEnumerable(<span class="string">'x'</span>)) // <span class="literal">true</span></div><div class="line">console.log(o.propertyIsEnumerable(<span class="string">'y'</span>)) // <span class="literal">false</span></div><div class="line">console.log(Object.prototype.propertyIsEnumerable(<span class="string">'toString'</span>)) // <span class="literal">false</span> 不可枚举</div></pre></td></tr></table></figure>
<h3 id="‘-‘判断一个属性是否是-undefinded"><a href="#‘-‘判断一个属性是否是-undefinded" class="headerlink" title="‘ !== ‘判断一个属性是否是 undefinded"></a>‘ !== ‘判断一个属性是否是 undefinded</h3><p>in 可以区分不存在的属性和存在但值为 undefined 的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(o.x !== undefined) // <span class="literal">true</span></div><div class="line">console.log(o.y !== undefined) // <span class="literal">false</span></div><div class="line">console.log(o.toString !== undefined) // <span class="literal">true</span></div></pre></td></tr></table></figure>
<h2 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h2><h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for/in 循环"></a>for/in 循环</h3><p>for/in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承属性），对象继承的内置方法不可枚举</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  z: 3</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(var p <span class="keyword">in</span> o) &#123;</div><div class="line">  console.log(p) // x y z</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>Object.keys() 返回一个数组，这个数组由对象中可枚举的自有属性的名称组成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  z: 3</div><div class="line">&#125;</div><div class="line">console.log(Object.keys(o)) // [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</div></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>Object.getOwnPropertyNames() 返回对象的所有自有属性的名称，而不仅仅是可枚举的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  z: 3</div><div class="line">&#125;</div><div class="line">console.log(Object.getOwnPropertyNames(o)) // [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</div></pre></td></tr></table></figure>
<h2 id="属性-getter-和-setter"><a href="#属性-getter-和-setter" class="headerlink" title="属性 getter 和 setter"></a>属性 getter 和 setter</h2><blockquote>
<p>一个 getter 是一个获取某个特定属性的值的方法；一个 setter 是一个设置某个属性的值得方法。由 getter 和 setter 定义的属性称做”存取器属性“，它不同于”数据属性“，数据属性只有一个简单的值。当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数)。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。</p>
</blockquote>
<ul>
<li>在对象初始化的时候定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  get <span class="function"><span class="title">p</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> this.x + this.y</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">set</span> p(newValue) &#123;</div><div class="line">    this.x += newValue</div><div class="line">    this.y += newValue</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">console.log(o.p) // 3</div><div class="line">o.p = 1</div><div class="line">console.log(o.x + <span class="string">'-'</span> + o.y) // 2-3</div></pre></td></tr></table></figure>
<ul>
<li>在对象定义后的时候定义<br>定义一个已经声明的函数作为的getter和setter方法，使用Object.defineProperty(或者 Object.prototype.<strong>defineGetter</strong> 旧语法回退)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2</div><div class="line">&#125;</div><div class="line">Object.defineProperty(o, <span class="string">'p'</span>, &#123;</div><div class="line">  get: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> this.x + this.y</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(newValue) &#123;</div><div class="line">    this.x += newValue</div><div class="line">    this.y += newValue</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">console.log(o.p) // 3</div><div class="line">o.p = 1</div><div class="line">console.log(o.x + <span class="string">'-'</span> + o.y) // 2-3</div></pre></td></tr></table></figure>
<h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><p>所有通过 ES3 的程序创建的属性都是可写的，可枚举的，可配置的，且无法对这些特性做修改。ES5 中可以查询和设置这些属性特性。</p>
<p>一个属性包含一个名字和4个特性。数据属性的4个特性分别是值（value）、可写性（writable）、可枚举性（enumerable)、可配置性（configurable)。存取器属性不具有值特性和可写性，它们的可写性是有setter 方法 存在与否决定的。因此存取器属性的4个特性是读取（get)、写入（set)、可枚举和可配置性。为了实现属性特性的查询和设置操作，ES5 定义了一个名为”属性描述符“的对象。</p>
<ul>
<li>Object.getOwnPropertyDescriptor() 可以获得某个对象特定属性的属性描述符，只能得到自有属性</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Object &#123;value: 1, writable: <span class="literal">true</span>, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span>&#125;</div><div class="line">console.log(Object.getOwnPropertyDescriptor(&#123; x: 1 &#125;, <span class="string">'x'</span>)) </div><div class="line">    </div><div class="line">console.log(Object.getOwnPropertyDescriptor(&#123; x: 1 &#125;, <span class="string">'toString'</span>)) // undefined</div></pre></td></tr></table></figure>
<ul>
<li>Object.defineProperty() 设置属性的特性或者想让新建属性具有某种特性，多个的话使用 Object.definePropertyies()</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2</div><div class="line">&#125;</div><div class="line">Object.defineProperty(o, <span class="string">'p'</span>, &#123;</div><div class="line">  get: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> this.x + this.y</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(newValue) &#123;</div><div class="line">    this.x += newValue</div><div class="line">    this.y += newValue</div><div class="line">  &#125;,</div><div class="line">  enumerable: <span class="literal">false</span>,</div><div class="line">  configurable: <span class="literal">false</span></div><div class="line">&#125;)</div><div class="line">// Object &#123;enumerable: <span class="literal">false</span>, configurable: <span class="literal">false</span>, get: <span class="keyword">function</span>, <span class="built_in">set</span>: <span class="keyword">function</span>&#125;</div><div class="line">console.log(Object.getOwnPropertyDescriptor(o, <span class="string">'p'</span>))</div></pre></td></tr></table></figure>
<p>任何对 Object.defineProperty() 违反规则的使用都会抛出类型错误异常，完整规则如下：</p>
<ul>
<li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</li>
<li>如果属性是不可配置的，则不能修改它的可枚举性和可配置性</li>
<li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性</li>
<li>如果数据属性是不可配置的，则不能将它转换为存取器属性</li>
<li>如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true 修改为 false</li>
<li>如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对象是JavaScript的基本数据类型。对象是一种复合值；它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。对象也可以看作是属性的无序集合，每个属性都是一个名值对。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中各种宽度和高度</title>
    <link href="http://sunmaer.github.io/2017/05/19/JavaScript%E8%8E%B7%E5%8F%96%E5%90%84%E7%A7%8D%E5%AE%BD%E5%BA%A6%E5%92%8C%E9%AB%98%E5%BA%A6/"/>
    <id>http://sunmaer.github.io/2017/05/19/JavaScript获取各种宽度和高度/</id>
    <published>2017-05-19T03:53:39.000Z</published>
    <updated>2017-09-12T13:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>总结 JavaScript 中各种宽度和高度。</p>
</blockquote>
<a id="more"></a>
<h2 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h2><blockquote>
<p>Window 对象表示浏览器中打开的窗口。如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</p>
</blockquote>
<ul>
<li>innerHeight 返回窗口的文档显示区的高度（不包括浏览器的状态栏）</li>
<li>innerWidth 返回窗口的文档显示区的宽度</li>
<li>outerHeight 返回窗口的外部高度（包括浏览器的状态栏，IE 不支持此属性）</li>
<li>outerWidth 返回窗口的外部宽度 （IE 不支持此属性）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 浏览器为全屏状态，屏幕分辨率：1440 x 900</div><div class="line">console.log(window.innerHeight) // 803</div><div class="line">console.log(window.innerWidth) // 1440</div><div class="line">console.log(window.outerHeight) // 900</div><div class="line">console.log(window.outerWidth) // 1440</div></pre></td></tr></table></figure>
<h2 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h2><blockquote>
<p>Screen 对象包含有关客户端显示屏幕的信息。</p>
</blockquote>
<ul>
<li>availHeight 返回显示屏幕的高度，（通常与屏幕的宽度、高度一致）</li>
<li>availWidth 返回显示屏幕的宽度，（通常与屏幕的宽度、高度一致）</li>
<li>height 屏幕的高度（指的是屏幕的分辨率，单位为像素）</li>
<li>width 屏幕的宽度（指的是屏幕的分辨率，单位为像素）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 屏幕分辨率：1440 x 900</div><div class="line">console.log(screen.availHeight) // 900</div><div class="line">console.log(screen.availWidth) // 1440</div><div class="line">console.log(screen.height) // 900</div><div class="line">console.log(screen.width) // 1440</div></pre></td></tr></table></figure>
<h2 id="Element-对象"><a href="#Element-对象" class="headerlink" title="Element 对象"></a>Element 对象</h2><blockquote>
<p>Element 对象表示 XML 文档中的元素。元素可包含属性、其他元素或文本。如果元素含有文本，则在文本节点中表示该文本。</p>
</blockquote>
<ul>
<li>clientHeight 在页面上返回内容的可视高度（不包括边框、滚动条）</li>
<li>clientWidth     在页面上返回内容的可视宽度（不包括边框、滚动条）<ul>
<li>有滚动条时：clientWidth = 元素左内边距宽度+元素宽度+元素右内边距宽度-元素垂直滚动条宽度</li>
<li>无滚动条时：clientWidth = 元素左内边距宽度+元素宽度+元素右内边距宽度</li>
<li>clientHeight 类似</li>
</ul>
</li>
<li>offsetHeight 返回，任何一个元素的高度包括边框和填充</li>
<li>offsetWidth     返回元素的宽度，包括边框和填充</li>
<li>offsetLeft    返回当前元素左上角相对于  HTMLElement.offsetParent 节点的左边界偏移的像素值</li>
<li>offsetParent 返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table, table cell 或根元素（标准模式下为 html；quirks 模式下为 body）。当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的</li>
<li>offsetTop 返回当前元素相对于其 offsetParent 元素的顶部的距离<ul>
<li>offsetWidth = 元素左边框宽度+元素左内边距宽度+元素宽度+元素右内边距宽度+元素右边框宽度</li>
</ul>
</li>
<li>scrollHeight 返回整个元素的高度（包括带滚动条的隐蔽的地方）</li>
<li>scrollLeft 返回当前视图中的实际元素的左边缘和左边缘之间的距离</li>
<li>scrollTop 返回当前视图中的实际元素的顶部边缘和顶部边缘之间的距离</li>
<li>scrollWidth     返回元素的整个宽度（包括带滚动条的隐蔽的地方）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">	&lt;title&gt;Js中获取各种宽度和高度&lt;/title&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		<span class="comment">#block1 &#123;</span></div><div class="line">			width: 500px;</div><div class="line">			height: 500px;</div><div class="line">			overflow: scroll;</div><div class="line">			background-color: red;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">#block2 &#123;</span></div><div class="line">			width: 600px;</div><div class="line">			height: 600px;</div><div class="line">			padding: 20px;</div><div class="line">			border: 10px solid blue;</div><div class="line">			margin: 0 auto;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=<span class="string">"block1"</span>&gt;</div><div class="line">		&lt;div id=<span class="string">"block2"</span>&gt;&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line"></div><div class="line">	&lt;script&gt;</div><div class="line">		var block = document.getElementById(<span class="string">'block2'</span>);</div><div class="line">		console.log(block.clientHeight) // 640 = 600 + 20 + 20</div><div class="line">		console.log(block.clientWidth) // 440 = 400 + 20 + 20</div><div class="line">		console.log(block.offsetHeight) // 660 = 600 + 20 + 20 + 10 +10</div><div class="line">		console.log(block.offsetWidth) // 460 = 400 + 20 + 20 +10 + 10</div><div class="line">		console.log(block.offsetLeft) // 28 外边距20加上浏览器默认的8</div><div class="line">		console.log(block.offsetParent) // body 对象，如果 block1 设置定位后则为 block1</div><div class="line">		console.log(block.offsetTop) // 0</div><div class="line">		console.log(block.scrollHeight) // 640</div><div class="line">		console.log(block.scrollLeft) // 0</div><div class="line">		console.log(block.scrollTop) // 0</div><div class="line">		console.log(block.scrollWidth) // 440</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="JS-获取样式"><a href="#JS-获取样式" class="headerlink" title="JS 获取样式"></a>JS 获取样式</h2><ul>
<li>style 属性</li>
</ul>
<p>元素的 style 属性代表了元素的内联样式，它覆盖了所有的样式表，它是设置 CSS 属性值来改变元素的视觉表现最好的地方。不能查询外部样式表。</p>
<ul>
<li>getComputedStyle() 方法</li>
</ul>
<p>浏览器窗口对象的 getComputedStyle() 方法可以获得一个元素的计算样式，只读。这个方法有两个参数，第一个是元素，第二个也是必须的，通常是 null或空字符串，也可以是 CSS 伪对象，如 “:after”。IE8 或更早的版本不支持该方法。</p>
<ul>
<li>currentStyle 属性</li>
</ul>
<p>在 IE 中，每个 HTML 元素有自己的 currentStyle 属性，组合了内联样式和样式表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">	&lt;title&gt;Js中获取样式&lt;/title&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		<span class="comment">#block &#123;</span></div><div class="line">			border: 5px solid blue;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=<span class="string">"block"</span> style=<span class="string">"width: 100%; height: 200px; background-color: red;"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">	&lt;script&gt;</div><div class="line">		var block = document.getElementById(<span class="string">'block'</span>);</div><div class="line">		console.log(block.style.width); // 100%</div><div class="line">		console.log(getComputedStyle(block, null).width); // 728px</div><div class="line">		console.log(block.style.height); // 200px</div><div class="line">		console.log(getComputedStyle(block, null).height); // 200px</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;总结 JavaScript 中各种宽度和高度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量的JavaScript代码</title>
    <link href="http://sunmaer.github.io/2017/05/07/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81/"/>
    <id>http://sunmaer.github.io/2017/05/07/编写高质量的JavaScript代码/</id>
    <published>2017-05-07T14:09:47.000Z</published>
    <updated>2017-08-12T13:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>全局变量的问题</p>
</blockquote>
<p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p>
<a id="more"></a>
<blockquote>
<p>隐式全局变量和明确定义的全局变量差异</p>
</blockquote>
<ul>
<li>通过var创建的全局变量是不能被删除的</li>
<li>无var创建的隐式全局变量是能被删除的</li>
</ul>
<p>隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 定义三个全局变量</div><div class="line">var global1 = <span class="string">"Hello World"</span>;</div><div class="line">global2 = <span class="string">"Hello World"</span>;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  global3 = <span class="string">"Hello World"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 删除全局变量</div><div class="line">console.log(delete global1); // <span class="literal">false</span></div><div class="line">console.log(delete global2); // <span class="literal">true</span></div><div class="line">console.log(delete global3); // <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>ES5严格模式下，未声明的变量工作时会抛出一个错误</p>
<blockquote>
<p>单var形式</p>
</blockquote>
<p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p>
<ul>
<li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li>
<li>防止变量在定义之前使用的逻辑错误</li>
<li>帮助你记住声明的全局变量</li>
<li>少代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</div><div class="line">  var a = 1,</div><div class="line">      b = 2,</div><div class="line">      sum = a + b,</div><div class="line">      myObject = &#123;&#125;,</div><div class="line">      i,</div><div class="line">      j;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>for循环缓存数组的长度</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var i = 0,</div><div class="line">    length,</div><div class="line">    myArr = [];</div><div class="line"><span class="keyword">for</span>(i = 0, length = myArr.length; i &lt; length; i++) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提升性能的形式：</p>
<ul>
<li>少了一个变量（无max）</li>
<li>向下数到0,通常更快，因为和0作比较要比和数组长度或是其他不适0的东西作比较更有效率</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var i, myArr = [];</div><div class="line"><span class="keyword">for</span>(i = myArr.length; i--) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>for-in循环</p>
</blockquote>
<p>for-in循环应该用在非数组对象的遍历上，使用for-in循环也被称为“枚举”。另外，在for-in中，属性列表的顺序是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。</p>
<blockquote>
<p>避免隐式类型转换</p>
<p>避免eval()</p>
<p>parseInt()下的数值转换</p>
</blockquote>
<p>不应该省略基数参数</p>
<blockquote>
<p>按强类型风格编写代码</p>
</blockquote>
<ul>
<li>定义变量的时候要指明类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var num = 0,</div><div class="line">    str = <span class="string">''</span>,</div><div class="line">    obj = null;</div></pre></td></tr></table></figure>
<ul>
<li>不要随意的改变变量类型</li>
<li>函数的返回类型应该是要确定的</li>
</ul>
<blockquote>
<p>减少作用域查找</p>
</blockquote>
<ul>
<li>不要让代码暴露在全局作用域下，使用立即执行匿名函数</li>
<li>不要滥用闭包</li>
</ul>
<blockquote>
<p>避免 == 的使用</p>
</blockquote>
<ul>
<li>如果变量类型确定，就没必要使用 == </li>
<li>如果变量类型不确定，手动类型转换</li>
<li>使用 == 在JSLint检查的时候是不通过的</li>
<li>== 可能会出现一些奇怪的现象</li>
</ul>
<blockquote>
<p>合并表达式</p>
</blockquote>
<ul>
<li>用三目运算符取代简单的if-else</li>
<li>连等</li>
<li>自增</li>
</ul>
<blockquote>
<p>使用ES6语法简化代码</p>
</blockquote>
<ul>
<li>使用箭头函数取代小函数</li>
<li>使用ES6的class</li>
<li>字符串拼接</li>
<li>块级作用域变量</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;全局变量的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>初识 node.js</title>
    <link href="http://sunmaer.github.io/2017/05/03/%E5%88%9D%E8%AF%86node.js/"/>
    <id>http://sunmaer.github.io/2017/05/03/初识node.js/</id>
    <published>2017-05-03T13:01:04.000Z</published>
    <updated>2017-08-03T13:24:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>分久必合，合久必分</p>
</blockquote>
<a id="more"></a>
<p>用了半天时间看完 Node.js 的基本API,感觉很轻便，没有Java那么笨重。很多语法在学习 Vue 的时候也见过，所以并没有什么陌生感，很快便熟悉了基本的用法。于是便参考别人的博客写了个学院官网的爬虫，程序能够获取文章内容和图片，然后存储在本地。不过当前版本过于简单，唯一的思想就是向服务器发送请求，获取文章的 html，使用 cheerio（类似Jquery)模块解析出 html 中的文字和图片。幸运的是，通过编写爬虫，折腾了一下 vim，熟悉了 vim 的配置和终端中一些常用的命令。代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">var http = require(<span class="string">'http'</span>)</div><div class="line">var fs = require(<span class="string">'fs'</span>)</div><div class="line">var cheerio = require(<span class="string">'cheerio'</span>)</div><div class="line">var request = require(<span class="string">'request'</span>)</div><div class="line"></div><div class="line">var i = 0</div><div class="line">// 初始化 URL</div><div class="line">var url = <span class="string">"http://coi.hzau.edu.cn/index.php/index-view-aid-1815.html"</span></div><div class="line"></div><div class="line"><span class="keyword">function</span> fetchPage(x) &#123; //封装函数</div><div class="line">	startRequest(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> startRequest(x) &#123;</div><div class="line">	// 采用 http 模块向服务器发起一次 get 请求</div><div class="line">	http.get(x, <span class="keyword">function</span>(res) &#123;</div><div class="line">		<span class="built_in">let</span> html = <span class="string">''</span> // 用来存储请求网页的整个 html 内容</div><div class="line">		<span class="built_in">let</span> titles = []</div><div class="line">		res.setEncoding(<span class="string">'utf-8'</span>) // 防止中文乱码</div><div class="line">		// 监听 data 事件，每次取一块数据</div><div class="line">		res.on(<span class="string">'data'</span>, <span class="keyword">function</span>(chunk) &#123;</div><div class="line">			html += chunk</div><div class="line">		&#125;)</div><div class="line">		// 监听 end 事件，如果整个网页内容的 html 都获取完毕，就执行回调函数</div><div class="line">		res.on(<span class="string">'end'</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">			<span class="built_in">let</span> $ = cheerio.load(html) // 采用 cheerio 模块解析 html</div><div class="line">			<span class="built_in">let</span> time = $(<span class="string">'.info .fl'</span>).eq(0).text().trim().split(<span class="string">'：'</span>)[1]</div><div class="line">			<span class="built_in">let</span> news_item = &#123;</div><div class="line">				// 获取文章标题</div><div class="line">				title: $(<span class="string">'.art_title h4'</span>).text().trim(),</div><div class="line">				// 获取文章发布时间</div><div class="line">				time: time,</div><div class="line">				// 获取作者</div><div class="line">				author: $(<span class="string">'.info .fl'</span>).eq(1).text().trim().split(<span class="string">'：'</span>)[1],</div><div class="line">				// 获取文章的浏览次数</div><div class="line">				views: $(<span class="string">'.info .fl'</span>).eq(2).text().trim().split(<span class="string">'：'</span>)[1],</div><div class="line">				// 文章 URL</div><div class="line">				url: x,</div><div class="line">				// i 是用来判断获取了多少篇文章</div><div class="line">				i: i+1</div><div class="line">			&#125;</div><div class="line">			console.log(news_item) // 打印新闻信息</div><div class="line"></div><div class="line">			<span class="built_in">let</span> news_title = $(<span class="string">'.art_title h4'</span>).text().trim() </div><div class="line">			savedContent($, news_title) // 存储每篇新闻的标题和内容</div><div class="line">			savedImg($, news_title) // 存储每篇新闻的图片</div><div class="line"></div><div class="line">			// 下一篇文章的 URL</div><div class="line">			<span class="built_in">let</span> href = $(<span class="string">'.art_page p'</span>).eq(1).children(<span class="string">'a'</span>).attr(<span class="string">'href'</span>)</div><div class="line">			// 如果下一篇没有了，则结束</div><div class="line">			<span class="keyword">if</span>(href === <span class="string">'javascript:void(0)'</span>) &#123;</div><div class="line">				console.log(<span class="string">'文章抓取完毕，没有下一篇了'</span>)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="built_in">let</span> nextLink = <span class="string">"http://coi.hzau.edu.cn"</span> + href</div><div class="line">				<span class="keyword">if</span>(i &lt;= 100) &#123;</div><div class="line">					fetchPage(nextLink)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;).on(<span class="string">'error'</span>, <span class="keyword">function</span>(err) &#123;</div><div class="line">		console.log(err)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 爬取新闻内容资源</div><div class="line"><span class="keyword">function</span> savedContent($, news_title) &#123;</div><div class="line">	$(<span class="string">'.art_content p'</span>).each(<span class="keyword">function</span>(index, item) &#123;</div><div class="line">		<span class="built_in">let</span> span = $(this).children(<span class="string">'span'</span>)</div><div class="line">		<span class="keyword">if</span>(span.length) &#123;</div><div class="line">			<span class="built_in">let</span> content = <span class="string">''</span></div><div class="line">			span.each(<span class="keyword">function</span>(index, item) &#123;</div><div class="line">				content += $(this).text()</div><div class="line">			&#125;)</div><div class="line">			content += <span class="string">'\n'</span></div><div class="line">			<span class="keyword">if</span>(content) &#123;</div><div class="line">				fs.appendFile(<span class="string">'./data/'</span> + news_title + <span class="string">'.txt'</span>, content, <span class="string">'utf-8'</span>, <span class="keyword">function</span>(err) &#123;</div><div class="line">					<span class="keyword">if</span>(err) &#123;</div><div class="line">						console.log(err)</div><div class="line">					&#125;</div><div class="line">				&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取图片资源</div><div class="line"><span class="keyword">function</span> savedImg($, news_title) &#123;</div><div class="line">	$(<span class="string">'.art_content p img'</span>).each(<span class="keyword">function</span>(index, item) &#123;</div><div class="line">		<span class="built_in">let</span> src = $(this).attr(<span class="string">'src'</span>)</div><div class="line">		<span class="built_in">let</span> arr = src.split(<span class="string">'/'</span>)</div><div class="line">		<span class="built_in">let</span> img_title = arr[arr.length - 1]</div><div class="line">		<span class="built_in">let</span> img_src = <span class="string">''</span></div><div class="line">		<span class="keyword">if</span>(src.indexOf(<span class="string">'http'</span>) === -1) &#123;</div><div class="line">			img_src = <span class="string">'http://coi.hzau.edu.cn'</span> + src</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			img_src = src</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 采用 request 模块，向服务器发起一次请求，获取图片资源</div><div class="line">		request.head(img_src, <span class="keyword">function</span>(err, res, body) &#123;</div><div class="line">			<span class="keyword">if</span>(err) &#123;</div><div class="line">				console.log(err)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">		request(img_src).pipe(fs.createWriteStream(<span class="string">'./image/'</span> + news_title + <span class="string">'-'</span> + img_title))</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fetchPage(url) // 主程序开始运行</div></pre></td></tr></table></figure>
<p>当然，这个项目我会继续下去，目标是完成一个小的应用，前端用 Vue,后端 Node.js，希望通过这个项目入门 Node.js,还有就是为音乐App做一些准备。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分久必合，合久必分&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://sunmaer.github.io/categories/node-js/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
      <category term="node.js" scheme="http://sunmaer.github.io/tags/node-js/"/>
    
      <category term="爬虫" scheme="http://sunmaer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>IE hack</title>
    <link href="http://sunmaer.github.io/2017/04/21/IE-hack/"/>
    <id>http://sunmaer.github.io/2017/04/21/IE-hack/</id>
    <published>2017-04-21T14:22:23.000Z</published>
    <updated>2017-07-31T14:25:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>StatCounter是美国一家网站通讯流量监测机构，提供各种类型的统计报告以及网站流量统计服务。下面是StateCounter网站统计的国内这一年不同浏览器以及不同版本浏览器的使用情况：</p>
</blockquote>
<a id="more"></a>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/blog/2.png" alt="IE hack"></p>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/blog/1.png" alt="IE hack"></p>
<p>可见在国内，IE还是占有一定的市场，所以必须考虑浏览器兼容性问题，特别是低版本的IE浏览器。</p>
<p>首先我们来了解下CSS hack。CSS hack是因为现有浏览器对标准的解析不同，为了兼容各浏览器，所采用的一种补救方法。CSS hack是一种类似作弊的手段，以欺骗浏览器的方式达到兼容的目的，是用浏览器的兼容性差异来解决浏览器的兼容性问题。因此，在设计之初，写CSS hack需要遵循以下三条原则：</p>
<ul>
<li>有效： 能够通过 Web 标准的验证</li>
<li>只针对太古老的/不再开发的/已被抛弃的浏览器， 而不是目前的主流浏览器</li>
<li>代码要丑陋。让人记住这是一个不得已而为之的 Hack, 时刻记住要想办法去掉它。现在很多hacks已经抛弃了最初的原则，而滥用hack会导致浏览器更新之后产生更多的兼容性问题。因此，并不推荐使用CSS hack来解决兼容性问题。</li>
</ul>
<p>IE hack方式一：条件注释法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</div></pre></td></tr></table></figure>
<p>IE hack方式二：类内属性前缀法</p>
<ul>
<li>“_″ 下划线是IE6专有的hack</li>
<li>“+” 加号IE6/7生效</li>
<li>“\9″ IE6/IE7/IE8/IE9/IE10都生效</li>
<li>“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</li>
<li>“\9\0″ 只对IE9/IE10生效，是IE9/10的hack</li>
</ul>
<p>IE hack方式三：选择器前缀法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*html *前缀只对IE6生效</div><div class="line">*+html *+前缀只对IE7生效</div><div class="line">@media screen\9&#123;...&#125;只对IE6/7生效</div><div class="line">@media \0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效</div><div class="line">@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效</div><div class="line">@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效</div><div class="line">@media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效</div><div class="line">@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效</div></pre></td></tr></table></figure>
<blockquote>
<p>参考网站：<a href="http://browserhacks.com/" target="_blank" rel="external">http://browserhacks.com/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;StatCounter是美国一家网站通讯流量监测机构，提供各种类型的统计报告以及网站流量统计服务。下面是StateCounter网站统计的国内这一年不同浏览器以及不同版本浏览器的使用情况：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="css" scheme="http://sunmaer.github.io/categories/css/"/>
    
    
      <category term="css" scheme="http://sunmaer.github.io/tags/css/"/>
    
      <category term="IE hack" scheme="http://sunmaer.github.io/tags/IE-hack/"/>
    
  </entry>
  
  <entry>
    <title>toString和valueOf</title>
    <link href="http://sunmaer.github.io/2017/04/06/toString%E5%92%8CvalueOf/"/>
    <id>http://sunmaer.github.io/2017/04/06/toString和valueOf/</id>
    <published>2017-04-06T08:52:24.000Z</published>
    <updated>2017-08-06T11:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h1><p>JavaScript中所有的对象继承了两个转换方法。第一个是toString()，它的作用是返回一个反映这个对象的字符串。<br><a id="more"></a><br>很多类定义了更多特定版本的toString()方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">行为描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Array</td>
<td style="text-align:center">将Array的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用逗号作为分隔符进行拼接</td>
</tr>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果布尔值是true，则返回”true”，否则返回”false”</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">返回日期的文本表示</td>
</tr>
<tr>
<td style="text-align:center">Error</td>
<td style="text-align:center">返回一个包含相关错误信息的字符串</td>
</tr>
<tr>
<td style="text-align:center">Function</td>
<td style="text-align:center">返回这个函数的实现定义的表示方法</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">返回数值的字符串表示</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">返回String对象的值</td>
</tr>
<tr>
<td style="text-align:center">Object(默认)</td>
<td style="text-align:center">返回”[object ObjectName]”</td>
</tr>
</tbody>
</table>
<h1 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h1><p>另一个转换方法是valueOf()。如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。</p>
<blockquote>
<p>对于所有非日期对象来说，对象到原始值的转换基本上是对象到数字的转换（首先调用valueOf(),但日期对象则使用对象到字符串的转换模式，但这种转换只执行一次就立即使用，不会像上面所说的那般先转字符串再转成相应的数字类型。</p>
</blockquote>
<p>如果只重写了toString()方法，对象转换时会无视valueOf的存在来进行转换；如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能使用valueOf()方法。</p>
<p>总结：</p>
<ol>
<li>在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。</li>
<li>在有运算操作符的情况下，valueOf的优先级高于toString。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;toString-NaN&quot;&gt;&lt;a href=&quot;#toString-NaN&quot; class=&quot;headerlink&quot; title=&quot;toString()&quot;&gt;&lt;/a&gt;toString()&lt;/h1&gt;&lt;p&gt;JavaScript中所有的对象继承了两个转换方法。第一个是toString()，它的作用是返回一个反映这个对象的字符串。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的line-height</title>
    <link href="http://sunmaer.github.io/2017/04/01/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84line-height/"/>
    <id>http://sunmaer.github.io/2017/04/01/你不知道的line-height/</id>
    <published>2017-04-01T12:14:23.000Z</published>
    <updated>2017-08-01T12:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是行间距？"><a href="#什么是行间距？" class="headerlink" title="什么是行间距？"></a>什么是行间距？</h3><p>行间距，即传说中控制两行文字之间垂直距离的东西。在CSS中，line-height被用来控制行与行之间的垂直间距。</p>
<a id="more"></a>
<h3 id="如何使用line-height？"><a href="#如何使用line-height？" class="headerlink" title="如何使用line-height？"></a>如何使用line-height？</h3><p>默认状态，浏览器使用1.0-1.2line-height，这是一个初始值。你可以定义CSS里的line-height属性来覆盖默认值。</p>
<p>5种方式定义line-height:</p>
<ul>
<li>1.line-height可以被定义为normal</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  line-height: normal; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有继承下来的元素不会忽略本身的font-size，而使用基于font-size算出来的line-height；浏览器在解释normal的时候会有细微的差别</p>
<ul>
<li>2.line-height可以被定义为继承</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: inherit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3.line-height可以使用一个百分比值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: 120%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>line-height的百分比和当前元素的字体大小被用来计算值，这个计算出来的值会被层叠下去的元素所继承；所有继承下来的元素会忽略本身的font-size，而使用相同的，计算出来的line-height</p>
<ul>
<li>4.line-height可以被定义为一个长度的值（单位px em等）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: 20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>长度值会被后代元素继承；所有继承下来的元素会忽略本身的font-size，而使用相同的，继承的line-height</p>
<ul>
<li>5.line-height也可以被定义为纯数字（甚至没有单位）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: 1.2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有继承下来的元素使用基于font-size算出来的line-height</p>
<p>line-height值也可以在font属性里缩写<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">font: 100%/normal arial;</div></pre></td></tr></table></figure>
<p>为了深入了解line-height，我们需要先来了解CSS boxes的各种类型:</p>
<ul>
<li>Box类型1：containing boxes</li>
</ul>
<p>段落就是一种containing boxes,它包含了其他的boxes</p>
<ul>
<li>Box类型2：inline boxes</li>
</ul>
<p>inline boxes不会让内容显示成块形式，而是排成一行</p>
<ul>
<li>Box类型3：line boxes</li>
</ul>
<p>inline boxes一个接一个组成了line boxes</p>
<ul>
<li>Box类型4：content area</li>
</ul>
<p>content area是围绕着文字的看不见的一种box，它的高取决于font-size</p>
<p>inline boxes与line-height<br>行高应用在inline-boxes上</p>
<p>line box高度取决于它外部最高的inline box（或被替换元素）</p>
<p>line box在containing box宽度内靠着彼此的顶部堆积</p>
<blockquote>
<p>参考网站：<a href="https://www.slideshare.net/daemao/line-height-2470819" target="_blank" rel="external">https://www.slideshare.net/daemao/line-height-2470819</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是行间距？&quot;&gt;&lt;a href=&quot;#什么是行间距？&quot; class=&quot;headerlink&quot; title=&quot;什么是行间距？&quot;&gt;&lt;/a&gt;什么是行间距？&lt;/h3&gt;&lt;p&gt;行间距，即传说中控制两行文字之间垂直距离的东西。在CSS中，line-height被用来控制行与行之间的垂直间距。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://sunmaer.github.io/categories/css/"/>
    
    
      <category term="line-height" scheme="http://sunmaer.github.io/tags/line-height/"/>
    
  </entry>
  
  <entry>
    <title>起航</title>
    <link href="http://sunmaer.github.io/2017/03/30/%E8%B5%B7%E8%88%AA/"/>
    <id>http://sunmaer.github.io/2017/03/30/起航/</id>
    <published>2017-03-30T06:22:17.000Z</published>
    <updated>2017-07-31T14:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当你的才华还撑不起你的野心时，那么你就应该静下心来学习。</p>
</blockquote>
<a id="more"></a>
<p>从今天起，定期更新博客，学习前端知识，记录人生感悟，分享所思所想。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当你的才华还撑不起你的野心时，那么你就应该静下心来学习。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="心情语录" scheme="http://sunmaer.github.io/categories/%E5%BF%83%E6%83%85%E8%AF%AD%E5%BD%95/"/>
    
    
      <category term="理想" scheme="http://sunmaer.github.io/tags/%E7%90%86%E6%83%B3/"/>
    
  </entry>
  
</feed>
