<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>單棲情緒</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunmaer.github.io/"/>
  <updated>2017-08-18T14:53:20.000Z</updated>
  <id>http://sunmaer.github.io/</id>
  
  <author>
    <name>sunmaer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue2.0中数据可视化库实现关系图</title>
    <link href="http://sunmaer.github.io/2017/08/18/Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E5%9B%BE/"/>
    <id>http://sunmaer.github.io/2017/08/18/Vue中使用数据可视化库实现关系图/</id>
    <published>2017-08-18T14:49:15.000Z</published>
    <updated>2017-08-18T14:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目地址：<a href="https://github.com/sunmaer/vue-charts" target="_blank" rel="external">https://github.com/sunmaer/vue-charts</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a><a href="http://echarts.baidu.com/index.html" target="_blank" rel="external">Echarts</a></h2><blockquote>
<p>版本：3.6.2</p>
</blockquote>
<ul>
<li>树状图<br>Echarts3中删除了tree图，但是我们通过自定义节点坐标还是可以实现一个简单的树图。给定节点层级，然后通过层级平均分布节点，不过这种方法存在的问题还是不少，建议使用D3.js实现树图，见后面。</li>
</ul>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/tree.png" alt="树状图"></p>
<ul>
<li>人物关系图</li>
</ul>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/net.png" alt="人物关系图"></p>
<h2 id="D3-js-组织结构图示例"><a href="#D3-js-组织结构图示例" class="headerlink" title="D3.js 组织结构图示例"></a><a href="https://d3js.org/" target="_blank" rel="external">D3.js</a> 组织结构图示例</h2><blockquote>
<p>版本：4.10.0</p>
</blockquote>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/organise.png" alt="组织结构图"></p>
<h2 id="jsPlumb-流程图示例"><a href="#jsPlumb-流程图示例" class="headerlink" title="jsPlumb 流程图示例"></a><a href="https://www.jsplumbtoolkit.com/community/doc/home.html" target="_blank" rel="external">jsPlumb</a> 流程图示例</h2><blockquote>
<p>版本：2.4.3</p>
</blockquote>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/flow.png" alt="流程图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/sunmaer/vue-charts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/sunmaer/vue-charts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="vue" scheme="http://sunmaer.github.io/categories/vue/"/>
    
    
      <category term="数据可视化" scheme="http://sunmaer.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="Echarts" scheme="http://sunmaer.github.io/tags/Echarts/"/>
    
      <category term="jsPlumb" scheme="http://sunmaer.github.io/tags/jsPlumb/"/>
    
      <category term="D3.js" scheme="http://sunmaer.github.io/tags/D3-js/"/>
    
      <category term="组织结构图" scheme="http://sunmaer.github.io/tags/%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/"/>
    
      <category term="树状图" scheme="http://sunmaer.github.io/tags/%E6%A0%91%E7%8A%B6%E5%9B%BE/"/>
    
      <category term="关系图" scheme="http://sunmaer.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript插入元素</title>
    <link href="http://sunmaer.github.io/2017/07/29/JavaScript%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0/"/>
    <id>http://sunmaer.github.io/2017/07/29/JavaScript插入元素/</id>
    <published>2017-07-29T03:21:51.000Z</published>
    <updated>2017-08-29T03:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我们平时经常会遇到动态插入 DOM 元素的场合，而在 JavaScript 中有多种方式可以实现插入 DOM，总结如下：</p>
</blockquote>
<a id="more"></a>
<h2 id="insertBefore-在指定的已有的子节点之前插入新节点"><a href="#insertBefore-在指定的已有的子节点之前插入新节点" class="headerlink" title="insertBefore()    在指定的已有的子节点之前插入新节点"></a>insertBefore()    在指定的已有的子节点之前插入新节点</h2><ul>
<li>调用了10000次ul.insertBefore()，每次都要产生一次页面渲染</li>
<li>在父元素末尾插入新节点性能和appendChild()差不多，如果在指定子节点前插入新节点，影响文档树中的其他元素，渲染开销较大</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">	<span class="built_in">let</span> li = document.createElement(<span class="string">'li'</span>)</div><div class="line">	<span class="built_in">let</span> a = document.createElement(<span class="string">'a'</span>)</div><div class="line">	<span class="built_in">let</span> text = document.createTextNode(<span class="string">'insertBefore()-'</span> + i)</div><div class="line">	a.appendChild(text)</div><div class="line">	li.appendChild(a)</div><div class="line">	ul.insertBefore(li, null)  // 第二个参数为 null 则在末尾插入新节点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="appendChild-向元素添加新的子节点，作为最后一个子节点"><a href="#appendChild-向元素添加新的子节点，作为最后一个子节点" class="headerlink" title="appendChild()    向元素添加新的子节点，作为最后一个子节点"></a>appendChild()    向元素添加新的子节点，作为最后一个子节点</h2><ul>
<li>调用了10000次ul.appendChild()，每次都要产生一次页面渲染</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">  <span class="built_in">let</span> li = document.createElement(<span class="string">'li'</span>)</div><div class="line">  <span class="built_in">let</span> a = document.createElement(<span class="string">'a'</span>)</div><div class="line">  <span class="built_in">let</span> text = document.createTextNode(<span class="string">'appendChild()-'</span> + i)</div><div class="line">  a.appendChild(text)</div><div class="line">  li.appendChild(a)</div><div class="line">  ul.appendChild(li)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="innerHTML-设置或返回元素的内容"><a href="#innerHTML-设置或返回元素的内容" class="headerlink" title="innerHTML 设置或返回元素的内容"></a>innerHTML 设置或返回元素的内容</h2><ul>
<li>只需要一次页面渲染</li>
<li>innerHTML 插入上万个节点的时候，如果要插入的DIV里是空的，那么用innerHTML 插入是最好的选择，速度也是最快的，但是当第二次插入的时候，你就会发现速度降低。如果div里已经有数据，innerHTML会逐一删除，然后再插入的新的数据，速度大大降低，此时建议使用文档片段方式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> liString = <span class="string">''</span></div><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">  liString += <span class="string">'&lt;li&gt;&lt;a href=""&gt;innerHTML-'</span> + i +<span class="string">'&lt;/a&gt;&lt;/li&gt;'</span></div><div class="line">&#125;</div><div class="line">ul.innerHTML = liString</div></pre></td></tr></table></figure>
<h2 id="文档片段-推荐）"><a href="#文档片段-推荐）" class="headerlink" title="文档片段(推荐）"></a>文档片段(推荐）</h2><ul>
<li>只需要一次页面渲染</li>
<li>虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。可以通过 appendChild() 或者 insertBefore() 将文档片段中内容添加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有子节点添加到相应位置上；文档片段本身永远不会成为文档树的一部分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var fragment = document.createDocumentFragment()</div><div class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=1; i&lt;=10000; i++) &#123;</div><div class="line">  <span class="built_in">let</span> li = document.createElement(<span class="string">'li'</span>)</div><div class="line">  <span class="built_in">let</span> a = document.createElement(<span class="string">'a'</span>)</div><div class="line">  <span class="built_in">let</span> text = document.createTextNode(<span class="string">'DocumentFragment-'</span> + i)</div><div class="line">  a.appendChild(text)</div><div class="line">  li.appendChild(a)</div><div class="line">  fragment.appendChild(li)</div><div class="line">&#125;</div><div class="line">ul.appendChild(fragment)</div></pre></td></tr></table></figure>
<h2 id="Jquery-插入-DOM-元素-append-方法源码"><a href="#Jquery-插入-DOM-元素-append-方法源码" class="headerlink" title="Jquery 插入 DOM 元素 append() 方法源码"></a>Jquery 插入 DOM 元素 append() 方法源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">append: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> domManip( this, arguments, <span class="keyword">function</span>( elem ) &#123;</div><div class="line">    <span class="keyword">if</span> ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) &#123;</div><div class="line">      var target = manipulationTarget( this, elem );</div><div class="line">      target.appendChild( elem );</div><div class="line">    &#125;</div><div class="line">  &#125; );</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们平时经常会遇到动态插入 DOM 元素的场合，而在 JavaScript 中有多种方式可以实现插入 DOM，总结如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="DOM" scheme="http://sunmaer.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件</title>
    <link href="http://sunmaer.github.io/2017/07/19/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    <id>http://sunmaer.github.io/2017/07/19/JavaScript事件/</id>
    <published>2017-07-19T11:27:05.000Z</published>
    <updated>2017-08-29T15:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>浏览器所支持的事件有很多，事件有三个来源：</p>
<p>3级 DOM 事件规范，经过长期的停滞之后，在 W3C 的主持下开始焕发生机。</p>
<p>HTML5 规范以及相关衍生规范的大量新 API 定义了新事件。</p>
<p>基于触摸和支持 JavaScript 的移动设备的出现，比如 iphone，它们需要定义新的触摸和手势事件类型。</p>
</blockquote>
<a id="more"></a> 
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE 的事件流叫做事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>不太具体的节点更早接收到事件，而最具体的节点最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。</p>
<h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><blockquote>
<p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定。这个特性的值应该是能够执行的 JavaScript 代码。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"点击"</span> onclick=<span class="string">"alert('Hello!')"</span> /&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"点击"</span> onclick=<span class="string">"hello()"</span> /&gt;</div></pre></td></tr></table></figure>
<p>通过 event 变量可以直接访问事件对象。在这个函数内部，this 的值等于事件的目标元素。</p>
<p>缺点：</p>
<ul>
<li>时差问题。如果 hello() 函数定义在页面的最底部，如果用户在页面解析 hello() 函数之前单击了按钮，就会引发错误。</li>
<li>HTMl 与 JavaScript 代码紧密耦合。</li>
</ul>
<h3 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h3><blockquote>
<p>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。</p>
</blockquote>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="title">function</span></span>() &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>如果这些代码在页面中位于按钮后面，就有可能在一段时间内怎么单击都没有反应。</p>
<p>程序中的 this 引用当前元素。</p>
<p>将事件处理程序属性的值设为 null 就可以删除事件处理程序。</p>
<h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">	alert(<span class="string">'1'</span>);</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>DOM2级方法添加事件处理程序可以添加多个事件处理程序。</p>
<p>通过 addEventListener() 添加的匿名函数将无法移除。</p>
<p>事件处理程序按照添加它们的顺序触发。</p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段。</p>
<h3 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">	alert(<span class="string">'1'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在使用 attachEvent() 方法情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window。</p>
<p>事件处理程序不是以它们添加的顺序执行，而是相反的顺序被触发。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;浏览器所支持的事件有很多，事件有三个来源：&lt;/p&gt;
&lt;p&gt;3级 DOM 事件规范，经过长期的停滞之后，在 W3C 的主持下开始焕发生机。&lt;/p&gt;
&lt;p&gt;HTML5 规范以及相关衍生规范的大量新 API 定义了新事件。&lt;/p&gt;
&lt;p&gt;基于触摸和支持 JavaScript 的移动设备的出现，比如 iphone，它们需要定义新的触摸和手势事件类型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="事件" scheme="http://sunmaer.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象</title>
    <link href="http://sunmaer.github.io/2017/05/20/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sunmaer.github.io/2017/05/20/JavaScript对象/</id>
    <published>2017-05-20T06:42:06.000Z</published>
    <updated>2017-08-22T14:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>对象是JavaScript的基本数据类型。对象是一种复合值；它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。对象也可以看作是属性的无序集合，每个属性都是一个名值对。</p>
</blockquote>
<a id="more"></a>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 对象直接量</div><div class="line">var person = &#123;</div><div class="line">  name: <span class="string">'sunmaer'</span>,</div><div class="line">  age: 21 // ECMAScript5中，最后一个属性后的逗号将忽略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="通过-new-创建对象"><a href="#通过-new-创建对象" class="headerlink" title="通过 new 创建对象"></a>通过 new 创建对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person2 = new Object();</div><div class="line">person2.name = <span class="string">'sunmaer'</span>;</div><div class="line">person2.age = 21;</div></pre></td></tr></table></figure>
<blockquote>
<p>原型：所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。</p>
</blockquote>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><blockquote>
<p>第一个参数指定对象的原型，第二个参数用以对对象的属性进行进一步描述</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person3 = Object.create(&#123;</div><div class="line">  name: <span class="string">'sunmaer'</span>,</div><div class="line">  age: 21</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>传入参数 null 将创建一个没有原型的新对象</li>
<li>传入 Object.prototype 创建一个普通的空对象（类似通过 {} 或 new Object() 创建的对象)</li>
</ul>
<h1 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h1><h2 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h2><ul>
<li>o 中的属性 p 是只读的：不能给只读属性重新弄赋值</li>
<li>o 中的属性 p 是继承属性，且它是只读的： 不能通过同名自有属性覆盖只读的继承属性</li>
<li>o 中不存在自有属性 p: o 没有使用 setter 方法机场属性 p，并且 o 的可扩展性是 false。</li>
</ul>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><ul>
<li>delete 只是断开属性和宿主对象的联系，而不会去操作属性中的属性</li>
<li>delete 只能删除自有属性，不能删除继承属性</li>
<li>严格模式中，delete 必须显示指定对象及其属性</li>
</ul>
<h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>如果对象的自有属性或继承属性中包含这个属性则返回 true</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(<span class="string">'x'</span> <span class="keyword">in</span> o) // <span class="literal">true</span></div><div class="line">console.log(<span class="string">'y'</span> <span class="keyword">in</span> o) // <span class="literal">false</span></div><div class="line">console.log(<span class="string">'toString'</span> <span class="keyword">in</span> o) // <span class="literal">true</span> o 继承toString属性</div></pre></td></tr></table></figure>
<h3 id="hasOwnProperty-和propertyIsEnumerable"><a href="#hasOwnProperty-和propertyIsEnumerable" class="headerlink" title="hasOwnProperty()和propertyIsEnumerable()"></a>hasOwnProperty()和propertyIsEnumerable()</h3><p>对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性，对于继承属性返回false</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(o.hasOwnProperty(<span class="string">'x'</span>)) // <span class="literal">true</span></div><div class="line">console.log(o.hasOwnProperty(<span class="string">'y'</span>)) // <span class="literal">false</span></div><div class="line">console.log(o.hasOwnProperty(<span class="string">'toString'</span>)) // <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>propertyIsEnumerable() 只有检测到时自身属性且这个属性的可枚举性为 true 时才返回true</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(o.propertyIsEnumerable(<span class="string">'x'</span>)) // <span class="literal">true</span></div><div class="line">console.log(o.propertyIsEnumerable(<span class="string">'y'</span>)) // <span class="literal">false</span></div><div class="line">console.log(Object.prototype.propertyIsEnumerable(<span class="string">'toString'</span>)) // <span class="literal">false</span> 不可枚举</div></pre></td></tr></table></figure>
<h3 id="‘-‘判断一个属性是否是-undefinded"><a href="#‘-‘判断一个属性是否是-undefinded" class="headerlink" title="‘ !== ‘判断一个属性是否是 undefinded"></a>‘ !== ‘判断一个属性是否是 undefinded</h3><p>in 可以区分不存在的属性和存在但值为 undefined 的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123; x: 1 &#125;</div><div class="line">console.log(o.x !== undefined) // <span class="literal">true</span></div><div class="line">console.log(o.y !== undefined) // <span class="literal">false</span></div><div class="line">console.log(o.toString !== undefined) // <span class="literal">true</span></div></pre></td></tr></table></figure>
<h2 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h2><h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for/in 循环"></a>for/in 循环</h3><p>for/in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承属性），对象继承的内置方法不可枚举</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  z: 3</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(var p <span class="keyword">in</span> o) &#123;</div><div class="line">  console.log(p) // x y z</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>Object.keys() 返回一个数组，这个数组由对象中可枚举的自有属性的名称组成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  z: 3</div><div class="line">&#125;</div><div class="line">console.log(Object.keys(o)) // [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</div></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>Object.getOwnPropertyNames() 返回对象的所有自有属性的名称，而不仅仅是可枚举的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  z: 3</div><div class="line">&#125;</div><div class="line">console.log(Object.getOwnPropertyNames(o)) // [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</div></pre></td></tr></table></figure>
<h2 id="属性-getter-和-setter"><a href="#属性-getter-和-setter" class="headerlink" title="属性 getter 和 setter"></a>属性 getter 和 setter</h2><blockquote>
<p>一个 getter 是一个获取某个特定属性的值的方法；一个 setter 是一个设置某个属性的值得方法。由 getter 和 setter 定义的属性称做”存取器属性“，它不同于”数据属性“，数据属性只有一个简单的值。当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数)。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。</p>
</blockquote>
<ul>
<li>在对象初始化的时候定义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2,</div><div class="line">  get <span class="function"><span class="title">p</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> this.x + this.y</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">set</span> p(newValue) &#123;</div><div class="line">    this.x += newValue</div><div class="line">    this.y += newValue</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">console.log(o.p) // 3</div><div class="line">o.p = 1</div><div class="line">console.log(o.x + <span class="string">'-'</span> + o.y) // 2-3</div></pre></td></tr></table></figure>
<ul>
<li>在对象定义后的时候定义<br>定义一个已经声明的函数作为的getter和setter方法，使用Object.defineProperty(或者 Object.prototype.<strong>defineGetter</strong> 旧语法回退)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2</div><div class="line">&#125;</div><div class="line">Object.defineProperty(o, <span class="string">'p'</span>, &#123;</div><div class="line">  get: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> this.x + this.y</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(newValue) &#123;</div><div class="line">    this.x += newValue</div><div class="line">    this.y += newValue</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">console.log(o.p) // 3</div><div class="line">o.p = 1</div><div class="line">console.log(o.x + <span class="string">'-'</span> + o.y) // 2-3</div></pre></td></tr></table></figure>
<h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><p>所有通过 ES3 的程序创建的属性都是可写的，可枚举的，可配置的，且无法对这些特性做修改。ES5 中可以查询和设置这些属性特性。</p>
<p>一个属性包含一个名字和4个特性。数据属性的4个特性分别是值（value）、可写性（writable）、可枚举性（enumerable)、可配置性（configurable)。存取器属性不具有值特性和可写性，它们的可写性是有setter 方法 存在与否决定的。因此存取器属性的4个特性是读取（get)、写入（set)、可枚举和可配置性。为了实现属性特性的查询和设置操作，ES5 定义了一个名为”属性描述符“的对象。</p>
<ul>
<li>Object.getOwnPropertyDescriptor() 可以获得某个对象特定属性的属性描述符，只能得到自有属性</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Object &#123;value: 1, writable: <span class="literal">true</span>, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span>&#125;</div><div class="line">console.log(Object.getOwnPropertyDescriptor(&#123; x: 1 &#125;, <span class="string">'x'</span>)) </div><div class="line">    </div><div class="line">console.log(Object.getOwnPropertyDescriptor(&#123; x: 1 &#125;, <span class="string">'toString'</span>)) // undefined</div></pre></td></tr></table></figure>
<ul>
<li>Object.defineProperty() 设置属性的特性或者想让新建属性具有某种特性，多个的话使用 Object.definePropertyies()</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  x: 1,</div><div class="line">  y: 2</div><div class="line">&#125;</div><div class="line">Object.defineProperty(o, <span class="string">'p'</span>, &#123;</div><div class="line">  get: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> this.x + this.y</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(newValue) &#123;</div><div class="line">    this.x += newValue</div><div class="line">    this.y += newValue</div><div class="line">  &#125;,</div><div class="line">  enumerable: <span class="literal">false</span>,</div><div class="line">  configurable: <span class="literal">false</span></div><div class="line">&#125;)</div><div class="line">// Object &#123;enumerable: <span class="literal">false</span>, configurable: <span class="literal">false</span>, get: <span class="keyword">function</span>, <span class="built_in">set</span>: <span class="keyword">function</span>&#125;</div><div class="line">console.log(Object.getOwnPropertyDescriptor(o, <span class="string">'p'</span>))</div></pre></td></tr></table></figure>
<p>任何对 Object.defineProperty() 违反规则的使用都会抛出类型错误异常，完整规则如下：</p>
<ul>
<li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</li>
<li>如果属性是不可配置的，则不能修改它的可枚举性和可配置性</li>
<li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性</li>
<li>如果数据属性是不可配置的，则不能将它转换为存取器属性</li>
<li>如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true 修改为 false</li>
<li>如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对象是JavaScript的基本数据类型。对象是一种复合值；它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。对象也可以看作是属性的无序集合，每个属性都是一个名值对。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中各种宽度和高度</title>
    <link href="http://sunmaer.github.io/2017/05/19/JavaScript%E8%8E%B7%E5%8F%96%E5%90%84%E7%A7%8D%E5%AE%BD%E5%BA%A6%E5%92%8C%E9%AB%98%E5%BA%A6/"/>
    <id>http://sunmaer.github.io/2017/05/19/JavaScript获取各种宽度和高度/</id>
    <published>2017-05-19T03:53:39.000Z</published>
    <updated>2017-08-20T03:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>总结 JavaScript 中各种宽度和高度。</p>
</blockquote>
<a id="more"></a>
<h2 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h2><blockquote>
<p>Window 对象表示浏览器中打开的窗口。如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</p>
</blockquote>
<ul>
<li>innerHeight 返回窗口的文档显示区的高度（不包括浏览器的状态栏）</li>
<li>innerWidth 返回窗口的文档显示区的宽度</li>
<li>outerHeight 返回窗口的外部高度（包括浏览器的状态栏，IE 不支持此属性）</li>
<li>outerWidth 返回窗口的外部宽度 （IE 不支持此属性）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 浏览器为全屏状态，屏幕分辨率：1440 x 900</div><div class="line">console.log(window.innerHeight) // 803</div><div class="line">console.log(window.innerWidth) // 1440</div><div class="line">console.log(window.outerHeight) // 900</div><div class="line">console.log(window.outerWidth) // 1440</div></pre></td></tr></table></figure>
<h2 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h2><blockquote>
<p>Screen 对象包含有关客户端显示屏幕的信息。</p>
</blockquote>
<ul>
<li>availHeight 返回显示屏幕的高度，（通常与屏幕的宽度、高度一致）</li>
<li>availWidth 返回显示屏幕的宽度，（通常与屏幕的宽度、高度一致）</li>
<li>height 屏幕的高度（指的是屏幕的分辨率，单位为像素）</li>
<li>width 屏幕的宽度（指的是屏幕的分辨率，单位为像素）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 屏幕分辨率：1440 x 900</div><div class="line">console.log(screen.availHeight) // 900</div><div class="line">console.log(screen.availWidth) // 1440</div><div class="line">console.log(screen.height) // 900</div><div class="line">console.log(screen.width) // 1440</div></pre></td></tr></table></figure>
<h2 id="Element-对象"><a href="#Element-对象" class="headerlink" title="Element 对象"></a>Element 对象</h2><blockquote>
<p>Element 对象表示 XML 文档中的元素。元素可包含属性、其他元素或文本。如果元素含有文本，则在文本节点中表示该文本。</p>
</blockquote>
<ul>
<li>clientHeight 在页面上返回内容的可视高度（不包括边框、滚动条）</li>
<li>clientWidth     在页面上返回内容的可视宽度（不包括边框、滚动条）<ul>
<li>有滚动条时：clientWidth = 元素左内边距宽度+元素宽度+元素右内边距宽度-元素垂直滚动条宽度</li>
<li>无滚动条时：clientWidth = 元素左内边距宽度+元素宽度+元素右内边距宽度</li>
<li>clientHeight 类似</li>
</ul>
</li>
<li>offsetHeight 返回，任何一个元素的高度包括边框和填充</li>
<li>offsetWidth     返回元素的宽度，包括边框和填充</li>
<li>offsetLeft    返回当前元素的相对水平偏移位置的偏移容器</li>
<li>offsetParent 返回元素的偏移容器，最近的定位的父元素，没有则为 body</li>
<li>offsetTop 返回当前元素的相对垂直偏移位置的偏移容器<ul>
<li>offsetWidth = 元素左边框宽度+元素左内边距宽度+元素宽度+元素右内边距宽度+元素右边框宽度</li>
</ul>
</li>
<li>scrollHeight 返回整个元素的高度（包括带滚动条的隐蔽的地方）</li>
<li>scrollLeft 返回当前视图中的实际元素的左边缘和左边缘之间的距离</li>
<li>scrollTop 返回当前视图中的实际元素的顶部边缘和顶部边缘之间的距离</li>
<li>scrollWidth     返回元素的整个宽度（包括带滚动条的隐蔽的地方）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">	&lt;title&gt;Js中获取各种宽度和高度&lt;/title&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		<span class="comment">#block1 &#123;</span></div><div class="line">			width: 500px;</div><div class="line">			height: 500px;</div><div class="line">			overflow: scroll;</div><div class="line">			background-color: red;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">#block2 &#123;</span></div><div class="line">			width: 600px;</div><div class="line">			height: 600px;</div><div class="line">			padding: 20px;</div><div class="line">			border: 10px solid blue;</div><div class="line">			margin: 0 auto;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=<span class="string">"block1"</span>&gt;</div><div class="line">		&lt;div id=<span class="string">"block2"</span>&gt;&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line"></div><div class="line">	&lt;script&gt;</div><div class="line">		var block = document.getElementById(<span class="string">'block2'</span>);</div><div class="line">		console.log(block.clientHeight) // 640 = 600 + 20 + 20</div><div class="line">		console.log(block.clientWidth) // 440 = 400 + 20 + 20</div><div class="line">		console.log(block.offsetHeight) // 660 = 600 + 20 + 20 + 10 +10</div><div class="line">		console.log(block.offsetWidth) // 460 = 400 + 20 + 20 +10 + 10</div><div class="line">		console.log(block.offsetLeft) // 28 外边距20加上浏览器默认的8</div><div class="line">		console.log(block.offsetParent) // body 对象，如果 block1 设置定位后则为 block1</div><div class="line">		console.log(block.offsetTop) // 0</div><div class="line">		console.log(block.scrollHeight) // 640</div><div class="line">		console.log(block.scrollLeft) // 0</div><div class="line">		console.log(block.scrollTop) // 0</div><div class="line">		console.log(block.scrollWidth) // 440</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="JS-获取样式"><a href="#JS-获取样式" class="headerlink" title="JS 获取样式"></a>JS 获取样式</h2><ul>
<li>style 属性</li>
</ul>
<p>元素的 style 属性代表了元素的内联样式，它覆盖了所有的样式表，它是设置 CSS 属性值来改变元素的视觉表现最好的地方。不能查询外部样式表。</p>
<ul>
<li>getComputedStyle() 方法</li>
</ul>
<p>浏览器窗口对象的 getComputedStyle() 方法可以获得一个元素的计算样式，只读。这个方法有两个参数，第一个是元素，第二个也是必须的，通常是 null或空字符串，也可以是 CSS 伪对象，如 “:after”。IE8 或更早的版本不支持该方法。</p>
<ul>
<li>currentStyle 属性</li>
</ul>
<p>在 IE 中，每个 HTML 元素有自己的 currentStyle 属性，组合了内联样式和样式表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">	&lt;title&gt;Js中获取样式&lt;/title&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		<span class="comment">#block &#123;</span></div><div class="line">			border: 5px solid blue;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=<span class="string">"block"</span> style=<span class="string">"width: 100%; height: 200px; background-color: red;"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">	&lt;script&gt;</div><div class="line">		var block = document.getElementById(<span class="string">'block'</span>);</div><div class="line">		console.log(block.style.width); // 100%</div><div class="line">		console.log(getComputedStyle(block, null).width); // 728px</div><div class="line">		console.log(block.style.height); // 200px</div><div class="line">		console.log(getComputedStyle(block, null).height); // 200px</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;总结 JavaScript 中各种宽度和高度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量的JavaScript代码</title>
    <link href="http://sunmaer.github.io/2017/05/07/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81/"/>
    <id>http://sunmaer.github.io/2017/05/07/编写高质量的JavaScript代码/</id>
    <published>2017-05-07T14:09:47.000Z</published>
    <updated>2017-08-12T13:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>全局变量的问题</p>
</blockquote>
<p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p>
<a id="more"></a>
<blockquote>
<p>隐式全局变量和明确定义的全局变量差异</p>
</blockquote>
<ul>
<li>通过var创建的全局变量是不能被删除的</li>
<li>无var创建的隐式全局变量是能被删除的</li>
</ul>
<p>隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 定义三个全局变量</div><div class="line">var global1 = <span class="string">"Hello World"</span>;</div><div class="line">global2 = <span class="string">"Hello World"</span>;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  global3 = <span class="string">"Hello World"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 删除全局变量</div><div class="line">console.log(delete global1); // <span class="literal">false</span></div><div class="line">console.log(delete global2); // <span class="literal">true</span></div><div class="line">console.log(delete global3); // <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>ES5严格模式下，未声明的变量工作时会抛出一个错误</p>
<blockquote>
<p>单var形式</p>
</blockquote>
<p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p>
<ul>
<li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li>
<li>防止变量在定义之前使用的逻辑错误</li>
<li>帮助你记住声明的全局变量</li>
<li>少代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</div><div class="line">  var a = 1,</div><div class="line">      b = 2,</div><div class="line">      sum = a + b,</div><div class="line">      myObject = &#123;&#125;,</div><div class="line">      i,</div><div class="line">      j;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>for循环缓存数组的长度</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var i = 0,</div><div class="line">    length,</div><div class="line">    myArr = [];</div><div class="line"><span class="keyword">for</span>(i = 0, length = myArr.length; i &lt; length; i++) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提升性能的形式：</p>
<ul>
<li>少了一个变量（无max）</li>
<li>向下数到0,通常更快，因为和0作比较要比和数组长度或是其他不适0的东西作比较更有效率</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var i, myArr = [];</div><div class="line"><span class="keyword">for</span>(i = myArr.length; i--) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>for-in循环</p>
</blockquote>
<p>for-in循环应该用在非数组对象的遍历上，使用for-in循环也被称为“枚举”。另外，在for-in中，属性列表的顺序是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。</p>
<blockquote>
<p>避免隐式类型转换</p>
<p>避免eval()</p>
<p>parseInt()下的数值转换</p>
</blockquote>
<p>不应该省略基数参数</p>
<blockquote>
<p>按强类型风格编写代码</p>
</blockquote>
<ul>
<li>定义变量的时候要指明类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var num = 0,</div><div class="line">    str = <span class="string">''</span>,</div><div class="line">    obj = null;</div></pre></td></tr></table></figure>
<ul>
<li>不要随意的改变变量类型</li>
<li>函数的返回类型应该是要确定的</li>
</ul>
<blockquote>
<p>减少作用域查找</p>
</blockquote>
<ul>
<li>不要让代码暴露在全局作用域下，使用立即执行匿名函数</li>
<li>不要滥用闭包</li>
</ul>
<blockquote>
<p>避免 == 的使用</p>
</blockquote>
<ul>
<li>如果变量类型确定，就没必要使用 == </li>
<li>如果变量类型不确定，手动类型转换</li>
<li>使用 == 在JSLint检查的时候是不通过的</li>
<li>== 可能会出现一些奇怪的现象</li>
</ul>
<blockquote>
<p>合并表达式</p>
</blockquote>
<ul>
<li>用三目运算符取代简单的if-else</li>
<li>连等</li>
<li>自增</li>
</ul>
<blockquote>
<p>使用ES6语法简化代码</p>
</blockquote>
<ul>
<li>使用箭头函数取代小函数</li>
<li>使用ES6的class</li>
<li>字符串拼接</li>
<li>块级作用域变量</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;全局变量的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>初识 node.js</title>
    <link href="http://sunmaer.github.io/2017/05/03/%E5%88%9D%E8%AF%86node.js/"/>
    <id>http://sunmaer.github.io/2017/05/03/初识node.js/</id>
    <published>2017-05-03T13:01:04.000Z</published>
    <updated>2017-08-03T13:24:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>分久必合，合久必分</p>
</blockquote>
<a id="more"></a>
<p>用了半天时间看完 Node.js 的基本API,感觉很轻便，没有Java那么笨重。很多语法在学习 Vue 的时候也见过，所以并没有什么陌生感，很快便熟悉了基本的用法。于是便参考别人的博客写了个学院官网的爬虫，程序能够获取文章内容和图片，然后存储在本地。不过当前版本过于简单，唯一的思想就是向服务器发送请求，获取文章的 html，使用 cheerio（类似Jquery)模块解析出 html 中的文字和图片。幸运的是，通过编写爬虫，折腾了一下 vim，熟悉了 vim 的配置和终端中一些常用的命令。代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">var http = require(<span class="string">'http'</span>)</div><div class="line">var fs = require(<span class="string">'fs'</span>)</div><div class="line">var cheerio = require(<span class="string">'cheerio'</span>)</div><div class="line">var request = require(<span class="string">'request'</span>)</div><div class="line"></div><div class="line">var i = 0</div><div class="line">// 初始化 URL</div><div class="line">var url = <span class="string">"http://coi.hzau.edu.cn/index.php/index-view-aid-1815.html"</span></div><div class="line"></div><div class="line"><span class="keyword">function</span> fetchPage(x) &#123; //封装函数</div><div class="line">	startRequest(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> startRequest(x) &#123;</div><div class="line">	// 采用 http 模块向服务器发起一次 get 请求</div><div class="line">	http.get(x, <span class="keyword">function</span>(res) &#123;</div><div class="line">		<span class="built_in">let</span> html = <span class="string">''</span> // 用来存储请求网页的整个 html 内容</div><div class="line">		<span class="built_in">let</span> titles = []</div><div class="line">		res.setEncoding(<span class="string">'utf-8'</span>) // 防止中文乱码</div><div class="line">		// 监听 data 事件，每次取一块数据</div><div class="line">		res.on(<span class="string">'data'</span>, <span class="keyword">function</span>(chunk) &#123;</div><div class="line">			html += chunk</div><div class="line">		&#125;)</div><div class="line">		// 监听 end 事件，如果整个网页内容的 html 都获取完毕，就执行回调函数</div><div class="line">		res.on(<span class="string">'end'</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">			<span class="built_in">let</span> $ = cheerio.load(html) // 采用 cheerio 模块解析 html</div><div class="line">			<span class="built_in">let</span> time = $(<span class="string">'.info .fl'</span>).eq(0).text().trim().split(<span class="string">'：'</span>)[1]</div><div class="line">			<span class="built_in">let</span> news_item = &#123;</div><div class="line">				// 获取文章标题</div><div class="line">				title: $(<span class="string">'.art_title h4'</span>).text().trim(),</div><div class="line">				// 获取文章发布时间</div><div class="line">				time: time,</div><div class="line">				// 获取作者</div><div class="line">				author: $(<span class="string">'.info .fl'</span>).eq(1).text().trim().split(<span class="string">'：'</span>)[1],</div><div class="line">				// 获取文章的浏览次数</div><div class="line">				views: $(<span class="string">'.info .fl'</span>).eq(2).text().trim().split(<span class="string">'：'</span>)[1],</div><div class="line">				// 文章 URL</div><div class="line">				url: x,</div><div class="line">				// i 是用来判断获取了多少篇文章</div><div class="line">				i: i+1</div><div class="line">			&#125;</div><div class="line">			console.log(news_item) // 打印新闻信息</div><div class="line"></div><div class="line">			<span class="built_in">let</span> news_title = $(<span class="string">'.art_title h4'</span>).text().trim() </div><div class="line">			savedContent($, news_title) // 存储每篇新闻的标题和内容</div><div class="line">			savedImg($, news_title) // 存储每篇新闻的图片</div><div class="line"></div><div class="line">			// 下一篇文章的 URL</div><div class="line">			<span class="built_in">let</span> href = $(<span class="string">'.art_page p'</span>).eq(1).children(<span class="string">'a'</span>).attr(<span class="string">'href'</span>)</div><div class="line">			// 如果下一篇没有了，则结束</div><div class="line">			<span class="keyword">if</span>(href === <span class="string">'javascript:void(0)'</span>) &#123;</div><div class="line">				console.log(<span class="string">'文章抓取完毕，没有下一篇了'</span>)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="built_in">let</span> nextLink = <span class="string">"http://coi.hzau.edu.cn"</span> + href</div><div class="line">				<span class="keyword">if</span>(i &lt;= 100) &#123;</div><div class="line">					fetchPage(nextLink)</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;).on(<span class="string">'error'</span>, <span class="keyword">function</span>(err) &#123;</div><div class="line">		console.log(err)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 爬取新闻内容资源</div><div class="line"><span class="keyword">function</span> savedContent($, news_title) &#123;</div><div class="line">	$(<span class="string">'.art_content p'</span>).each(<span class="keyword">function</span>(index, item) &#123;</div><div class="line">		<span class="built_in">let</span> span = $(this).children(<span class="string">'span'</span>)</div><div class="line">		<span class="keyword">if</span>(span.length) &#123;</div><div class="line">			<span class="built_in">let</span> content = <span class="string">''</span></div><div class="line">			span.each(<span class="keyword">function</span>(index, item) &#123;</div><div class="line">				content += $(this).text()</div><div class="line">			&#125;)</div><div class="line">			content += <span class="string">'\n'</span></div><div class="line">			<span class="keyword">if</span>(content) &#123;</div><div class="line">				fs.appendFile(<span class="string">'./data/'</span> + news_title + <span class="string">'.txt'</span>, content, <span class="string">'utf-8'</span>, <span class="keyword">function</span>(err) &#123;</div><div class="line">					<span class="keyword">if</span>(err) &#123;</div><div class="line">						console.log(err)</div><div class="line">					&#125;</div><div class="line">				&#125;)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取图片资源</div><div class="line"><span class="keyword">function</span> savedImg($, news_title) &#123;</div><div class="line">	$(<span class="string">'.art_content p img'</span>).each(<span class="keyword">function</span>(index, item) &#123;</div><div class="line">		<span class="built_in">let</span> src = $(this).attr(<span class="string">'src'</span>)</div><div class="line">		<span class="built_in">let</span> arr = src.split(<span class="string">'/'</span>)</div><div class="line">		<span class="built_in">let</span> img_title = arr[arr.length - 1]</div><div class="line">		<span class="built_in">let</span> img_src = <span class="string">''</span></div><div class="line">		<span class="keyword">if</span>(src.indexOf(<span class="string">'http'</span>) === -1) &#123;</div><div class="line">			img_src = <span class="string">'http://coi.hzau.edu.cn'</span> + src</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			img_src = src</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 采用 request 模块，向服务器发起一次请求，获取图片资源</div><div class="line">		request.head(img_src, <span class="keyword">function</span>(err, res, body) &#123;</div><div class="line">			<span class="keyword">if</span>(err) &#123;</div><div class="line">				console.log(err)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">		request(img_src).pipe(fs.createWriteStream(<span class="string">'./image/'</span> + news_title + <span class="string">'-'</span> + img_title))</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fetchPage(url) // 主程序开始运行</div></pre></td></tr></table></figure>
<p>当然，这个项目我会继续下去，目标是完成一个小的应用，前端用 Vue,后端 Node.js，希望通过这个项目入门 Node.js,还有就是为音乐App做一些准备。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分久必合，合久必分&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://sunmaer.github.io/categories/node-js/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
      <category term="node.js" scheme="http://sunmaer.github.io/tags/node-js/"/>
    
      <category term="爬虫" scheme="http://sunmaer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>IE hack</title>
    <link href="http://sunmaer.github.io/2017/04/21/IE-hack/"/>
    <id>http://sunmaer.github.io/2017/04/21/IE-hack/</id>
    <published>2017-04-21T14:22:23.000Z</published>
    <updated>2017-07-31T14:25:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>StatCounter是美国一家网站通讯流量监测机构，提供各种类型的统计报告以及网站流量统计服务。下面是StateCounter网站统计的国内这一年不同浏览器以及不同版本浏览器的使用情况：</p>
</blockquote>
<a id="more"></a>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/blog/2.png" alt="IE hack"></p>
<p><img src="http://otxtxlg3e.bkt.clouddn.com/blog/1.png" alt="IE hack"></p>
<p>可见在国内，IE还是占有一定的市场，所以必须考虑浏览器兼容性问题，特别是低版本的IE浏览器。</p>
<p>首先我们来了解下CSS hack。CSS hack是因为现有浏览器对标准的解析不同，为了兼容各浏览器，所采用的一种补救方法。CSS hack是一种类似作弊的手段，以欺骗浏览器的方式达到兼容的目的，是用浏览器的兼容性差异来解决浏览器的兼容性问题。因此，在设计之初，写CSS hack需要遵循以下三条原则：</p>
<ul>
<li>有效： 能够通过 Web 标准的验证</li>
<li>只针对太古老的/不再开发的/已被抛弃的浏览器， 而不是目前的主流浏览器</li>
<li>代码要丑陋。让人记住这是一个不得已而为之的 Hack, 时刻记住要想办法去掉它。现在很多hacks已经抛弃了最初的原则，而滥用hack会导致浏览器更新之后产生更多的兼容性问题。因此，并不推荐使用CSS hack来解决兼容性问题。</li>
</ul>
<p>IE hack方式一：条件注释法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</div></pre></td></tr></table></figure>
<p>IE hack方式二：类内属性前缀法</p>
<ul>
<li>“_″ 下划线是IE6专有的hack</li>
<li>“+” 加号IE6/7生效</li>
<li>“\9″ IE6/IE7/IE8/IE9/IE10都生效</li>
<li>“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</li>
<li>“\9\0″ 只对IE9/IE10生效，是IE9/10的hack</li>
</ul>
<p>IE hack方式三：选择器前缀法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*html *前缀只对IE6生效</div><div class="line">*+html *+前缀只对IE7生效</div><div class="line">@media screen\9&#123;...&#125;只对IE6/7生效</div><div class="line">@media \0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效</div><div class="line">@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效</div><div class="line">@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效</div><div class="line">@media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效</div><div class="line">@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效</div></pre></td></tr></table></figure>
<blockquote>
<p>参考网站：<a href="http://browserhacks.com/" target="_blank" rel="external">http://browserhacks.com/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;StatCounter是美国一家网站通讯流量监测机构，提供各种类型的统计报告以及网站流量统计服务。下面是StateCounter网站统计的国内这一年不同浏览器以及不同版本浏览器的使用情况：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="css" scheme="http://sunmaer.github.io/categories/css/"/>
    
    
      <category term="css" scheme="http://sunmaer.github.io/tags/css/"/>
    
      <category term="IE hack" scheme="http://sunmaer.github.io/tags/IE-hack/"/>
    
  </entry>
  
  <entry>
    <title>toString和valueOf</title>
    <link href="http://sunmaer.github.io/2017/04/06/toString%E5%92%8CvalueOf/"/>
    <id>http://sunmaer.github.io/2017/04/06/toString和valueOf/</id>
    <published>2017-04-06T08:52:24.000Z</published>
    <updated>2017-08-06T11:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h1><p>JavaScript中所有的对象继承了两个转换方法。第一个是toString()，它的作用是返回一个反映这个对象的字符串。<br><a id="more"></a><br>很多类定义了更多特定版本的toString()方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">行为描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Array</td>
<td style="text-align:center">将Array的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用逗号作为分隔符进行拼接</td>
</tr>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">如果布尔值是true，则返回”true”，否则返回”false”</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">返回日期的文本表示</td>
</tr>
<tr>
<td style="text-align:center">Error</td>
<td style="text-align:center">返回一个包含相关错误信息的字符串</td>
</tr>
<tr>
<td style="text-align:center">Function</td>
<td style="text-align:center">返回这个函数的实现定义的表示方法</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">返回数值的字符串表示</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">返回String对象的值</td>
</tr>
<tr>
<td style="text-align:center">Object(默认)</td>
<td style="text-align:center">返回”[object ObjectName]”</td>
</tr>
</tbody>
</table>
<h1 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h1><p>另一个转换方法是valueOf()。如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。</p>
<blockquote>
<p>对于所有非日期对象来说，对象到原始值的转换基本上是对象到数字的转换（首先调用valueOf(),但日期对象则使用对象到字符串的转换模式，但这种转换只执行一次就立即使用，不会像上面所说的那般先转字符串再转成相应的数字类型。</p>
</blockquote>
<p>如果只重写了toString()方法，对象转换时会无视valueOf的存在来进行转换；如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能使用valueOf()方法。</p>
<p>总结：</p>
<ol>
<li>在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。</li>
<li>在有运算操作符的情况下，valueOf的优先级高于toString。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;toString-NaN&quot;&gt;&lt;a href=&quot;#toString-NaN&quot; class=&quot;headerlink&quot; title=&quot;toString()&quot;&gt;&lt;/a&gt;toString()&lt;/h1&gt;&lt;p&gt;JavaScript中所有的对象继承了两个转换方法。第一个是toString()，它的作用是返回一个反映这个对象的字符串。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://sunmaer.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://sunmaer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的line-height</title>
    <link href="http://sunmaer.github.io/2017/04/01/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84line-height/"/>
    <id>http://sunmaer.github.io/2017/04/01/你不知道的line-height/</id>
    <published>2017-04-01T12:14:23.000Z</published>
    <updated>2017-08-01T12:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是行间距？"><a href="#什么是行间距？" class="headerlink" title="什么是行间距？"></a>什么是行间距？</h3><p>行间距，即传说中控制两行文字之间垂直距离的东西。在CSS中，line-height被用来控制行与行之间的垂直间距。</p>
<a id="more"></a>
<h3 id="如何使用line-height？"><a href="#如何使用line-height？" class="headerlink" title="如何使用line-height？"></a>如何使用line-height？</h3><p>默认状态，浏览器使用1.0-1.2line-height，这是一个初始值。你可以定义CSS里的line-height属性来覆盖默认值。</p>
<p>5种方式定义line-height:</p>
<ul>
<li>1.line-height可以被定义为normal</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  line-height: normal; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有继承下来的元素不会忽略本身的font-size，而使用基于font-size算出来的line-height；浏览器在解释normal的时候会有细微的差别</p>
<ul>
<li>2.line-height可以被定义为继承</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: inherit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3.line-height可以使用一个百分比值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: 120%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>line-height的百分比和当前元素的字体大小被用来计算值，这个计算出来的值会被层叠下去的元素所继承；所有继承下来的元素会忽略本身的font-size，而使用相同的，计算出来的line-height</p>
<ul>
<li>4.line-height可以被定义为一个长度的值（单位px em等）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: 20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>长度值会被后代元素继承；所有继承下来的元素会忽略本身的font-size，而使用相同的，继承的line-height</p>
<ul>
<li>5.line-height也可以被定义为纯数字（甚至没有单位）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">  line-height: 1.2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有继承下来的元素使用基于font-size算出来的line-height</p>
<p>line-height值也可以在font属性里缩写<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">font: 100%/normal arial;</div></pre></td></tr></table></figure>
<p>为了深入了解line-height，我们需要先来了解CSS boxes的各种类型:</p>
<ul>
<li>Box类型1：containing boxes</li>
</ul>
<p>段落就是一种containing boxes,它包含了其他的boxes</p>
<ul>
<li>Box类型2：inline boxes</li>
</ul>
<p>inline boxes不会让内容显示成块形式，而是排成一行</p>
<ul>
<li>Box类型3：line boxes</li>
</ul>
<p>inline boxes一个接一个组成了line boxes</p>
<ul>
<li>Box类型4：content area</li>
</ul>
<p>content area是围绕着文字的看不见的一种box，它的高取决于font-size</p>
<p>inline boxes与line-height<br>行高应用在inline-boxes上</p>
<p>line box高度取决于它外部最高的inline box（或被替换元素）</p>
<p>line box在containing box宽度内靠着彼此的顶部堆积</p>
<blockquote>
<p>参考网站：<a href="https://www.slideshare.net/daemao/line-height-2470819" target="_blank" rel="external">https://www.slideshare.net/daemao/line-height-2470819</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是行间距？&quot;&gt;&lt;a href=&quot;#什么是行间距？&quot; class=&quot;headerlink&quot; title=&quot;什么是行间距？&quot;&gt;&lt;/a&gt;什么是行间距？&lt;/h3&gt;&lt;p&gt;行间距，即传说中控制两行文字之间垂直距离的东西。在CSS中，line-height被用来控制行与行之间的垂直间距。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://sunmaer.github.io/categories/css/"/>
    
    
      <category term="line-height" scheme="http://sunmaer.github.io/tags/line-height/"/>
    
  </entry>
  
  <entry>
    <title>起航</title>
    <link href="http://sunmaer.github.io/2017/03/30/%E8%B5%B7%E8%88%AA/"/>
    <id>http://sunmaer.github.io/2017/03/30/起航/</id>
    <published>2017-03-30T06:22:17.000Z</published>
    <updated>2017-07-31T14:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当你的才华还撑不起你的野心时，那么你就应该静下心来学习。</p>
</blockquote>
<a id="more"></a>
<p>从今天起，定期更新博客，学习前端知识，记录人生感悟，分享所思所想。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当你的才华还撑不起你的野心时，那么你就应该静下心来学习。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="心情语录" scheme="http://sunmaer.github.io/categories/%E5%BF%83%E6%83%85%E8%AF%AD%E5%BD%95/"/>
    
    
      <category term="理想" scheme="http://sunmaer.github.io/tags/%E7%90%86%E6%83%B3/"/>
    
  </entry>
  
</feed>
